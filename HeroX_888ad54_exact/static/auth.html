<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HeroX — Authenticate Accounts</title>
  <style>
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#f8fafc;margin:0;padding:18px;color:#0f172a}
    .card{max-width:820px;margin:20px auto;background:#fff;padding:18px;border-radius:10px;box-shadow:0 10px 30px rgba(2,6,23,0.06)}
    h1{margin:0 0 8px 0;font-size:18px}
    label{display:block;margin-top:12px;font-size:13px;color:#374151}
    input[type="password"], input[type="text"]{width:100%;padding:10px;border:1px solid rgba(0,0,0,0.06);border-radius:8px;margin-top:6px;box-sizing:border-box}
    .row{display:flex;gap:12px;align-items:center;margin-top:12px}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer}
    button.secondary{background:transparent;color:#2563eb;border:1px solid rgba(37,99,235,0.12)}
    .muted{color:#6b7280;font-size:13px}
    .balance-box{display:flex;gap:16px;margin-top:12px}
    .balance-card{padding:10px;border:1px solid rgba(0,0,0,0.04);border-radius:8px;flex:1}
    .ok{color:#10b981;font-weight:700}
    .warn{color:#f59e0b;font-weight:700}
    .center{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:16px}
    .note{font-size:13px;color:#6b7280;margin-top:8px}
    .small-inline{font-size:13px;margin-left:8px}
  </style>
</head>
<body>
  <div class="card" role="main">
    <h1>Authenticate your HeroX accounts</h1>
    <div class="muted">Paste API tokens for Demo and/or Real accounts. You may authenticate either or both. After success you'll be returned to the dashboard and balances will appear.</div>

    <label for="demo-token">Demo API token (optional)</label>
    <input id="demo-token" type="password" placeholder="Paste Demo API token">

    <div class="row">
      <button id="demo-connect">Connect Demo</button>
      <button class="secondary" id="demo-fetch-bal">Fetch Demo Balances</button>
      <div id="demo-status" style="margin-left:auto" class="muted">—</div>
      <button id="demo-disconnect" class="secondary" style="margin-left:8px;display:none">Disconnect</button>
    </div>

    <label for="real-token">Real API token (optional)</label>
    <input id="real-token" type="password" placeholder="Paste Real API token">

    <div class="row">
      <button id="real-connect">Connect Real</button>
      <button class="secondary" id="real-fetch-bal">Fetch Real Balances</button>
      <div id="real-status" style="margin-left:auto" class="muted">—</div>
      <button id="real-disconnect" class="secondary" style="margin-left:8px;display:none">Disconnect</button>
    </div>

    <div class="balance-box" aria-hidden="true">
      <div class="balance-card">
        <div style="font-size:13px;color:#374151">Demo balance</div>
        <div id="demo-balance-display" style="font-weight:800;font-size:18px;margin-top:8px">—</div>
        <div id="demo-balance-meta" class="muted note"></div>
      </div>
      <div class="balance-card">
        <div style="font-size:13px;color:#374151">Real balance</div>
        <div id="real-balance-display" style="font-weight:800;font-size:18px;margin-top:8px">—</div>
        <div id="real-balance-meta" class="muted note"></div>
      </div>
    </div>

    <div class="center">
      <button id="done-btn">Done — return to dashboard</button>
      <button class="secondary" id="skip-btn">Skip & return</button>
    </div>

    <div class="note" id="auth-note">Tip: your tokens are stored locally in the browser and only used to request balances and quick connects.</div>
  </div>

  <script>
    // Small auth page client (updated with auto-refresh & disconnect)
    (function(){
      const APP_ID = 71710;
      const qs = new URLSearchParams(window.location.search || '');
      const returnTo = qs.get('return') ? decodeURIComponent(qs.get('return')) : '/';
      function showToast(msg, ok){ const el = document.getElementById('auth-note'); if(el){ el.textContent = msg; el.style.color = ok ? '#10b981' : '#ef4444'; setTimeout(()=>{ el.style.color=''; el.textContent='Tip: your tokens are stored locally in the browser and only used to request balances and quick connects.'; }, 2500);} }

      // polling defaults - reuse same defaults as the dashboard module
      const DEFAULT_POLL_MS = 1000;
      const MIN_POLL_MS = 250;
      let pollHandle = null;

      async function connectAccount(token, mode){
        if(!token || token.trim()===''){ showToast('Paste a token before connecting', false); return null; }
        try {
          const res = await fetch('/control/connect_account', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ token: token.trim(), app_id: APP_ID, mode })
          });
          let j = null;
          try { j = await res.json(); } catch(e){ j = null; }
          if(res.ok && j && j.ok){
            // store token locally
            try { localStorage.setItem(mode==='real' ? 'hero_token_real' : 'hero_token_demo', token.trim()); } catch(e){}
                        // Also persist token on server so hero_service can reuse it across restarts
            try {
              fetch('/control/set_token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: mode, token: token.trim() })
              }).then(resp => resp.json().then(j => {
                console.debug('server set_token result', j);
              })).catch(()=>{});
            } catch(e){}

            showToast(mode + ' connected, saved token', true);
            // if balances included in response, persist them
            if(j.balance || j.balances || j.amount){
              const balanceObj = j.balance || j.balances || j;
              try { localStorage.setItem('hero_balance_' + mode, JSON.stringify(balanceObj)); } catch(e){}
              applyBalanceToUI(mode, balanceObj);
            } else {
              // try fetching balances explicitly
              await fetchBalances(mode);
            }
            // Mark status
            updateStatus(mode, true);
            // show disconnect button on this page
            showDisconnectBtn(mode, true);
            // start polling balances (page-level)
            startPolling();
            return j;
          } else {
            const msg = j && (j.error || j.msg) ? (j.error || j.msg) : ('server ' + res.status);
            updateStatus(mode, false, msg);
            showToast('Connect failed: ' + msg, false);
            return null;
          }
        } catch(e){
          updateStatus(mode, false, e.message || String(e));
          showToast('Connect failed: network error', false);
          return null;
        }
      }

      function updateStatus(mode, ok, msg){
        const el = document.getElementById((mode==='real') ? 'real-status' : 'demo-status');
        if(!el) return;
        if(ok){ el.textContent = 'Authenticated'; el.className = 'ok'; } else { el.textContent = 'Failed' + (msg ? (': ' + msg) : ''); el.className = 'warn'; }
      }

      async function fetchBalances(mode){
        try {
          const r = await fetch('/control/get_balances?mode=' + encodeURIComponent(mode), { method: 'GET', headers: { 'Accept': 'application/json' } });
          if(!r.ok){ showToast('Failed to fetch balances ('+r.status+')', false); return null; }
          const j = await r.json();
          if(j && (j.balance || j.balances || j.amount)){
            const obj = j.balance || j.balances || j;
            try { localStorage.setItem('hero_balance_' + mode, JSON.stringify(obj)); } catch(e){}
            applyBalanceToUI(mode, obj);
            updateStatus(mode, true);
            // show disconnect button
            showDisconnectBtn(mode, true);
            return obj;
          } else {
            updateStatus(mode, false, j && j.error ? j.error : 'no balance in response');
            return j;
          }
        } catch(e){
          updateStatus(mode, false, e.message || String(e));
          return null;
        }
      }

      function applyBalanceToUI(mode, obj){
        try {
          const disp = document.getElementById((mode==='real') ? 'real-balance-display' : 'demo-balance-display');
          const meta = document.getElementById((mode==='real') ? 'real-balance-meta' : 'demo-balance-meta');
          if(!disp) return;
          let amount = '';
          let metaText = '';
          if(typeof obj === 'number') amount = obj;
          else if(obj.balance !== undefined && typeof obj.balance !== 'object') { amount = obj.balance; metaText = obj.currency || ''; }
          else if(obj.amount !== undefined) { amount = obj.amount; metaText = obj.currency || ''; }
          else if(obj.balance && typeof obj.balance === 'object' && obj.balance.balance !== undefined){ amount = obj.balance.balance; metaText = (obj.balance.currency || '') + (obj.balance.loginid ? ' • ' + obj.balance.loginid : ''); }
          else { amount = JSON.stringify(obj).slice(0,80); }
          disp.textContent = amount;
          meta.textContent = metaText;
        } catch(e){}
      }

      function showDisconnectBtn(mode, show){
        try{
          const id = mode === 'real' ? 'real-disconnect' : 'demo-disconnect';
          const el = document.getElementById(id);
          if(!el) return;
          el.style.display = show ? 'inline-block' : 'none';
        }catch(e){}
      }

      async function disconnectMode(mode){
        // clear tokens + balances for this mode
        try{
          if(mode==='real') localStorage.removeItem('hero_token_real');
          if(mode==='demo') localStorage.removeItem('hero_token_demo');
          if(mode==='real') localStorage.removeItem('hero_balance_real');
          if(mode==='demo') localStorage.removeItem('hero_balance_demo');
          updateStatus(mode, false);
          showDisconnectBtn(mode, false);
          applyBalanceToUI(mode, {});
          showToast((mode==='real' ? 'Real' : 'Demo') + ' disconnected and cleared', false);
          // optionally inform server
          try{ await fetch('/control/disconnect_account', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({mode}) }); }catch(e){}
          // if no tokens left, stop polling
          const left = !!localStorage.getItem('hero_token_demo') || !!localStorage.getItem('hero_token_real');
          if(!left) stopPolling();
        }catch(e){}
      }

      function startPolling(){
        try{
          if(pollHandle) return;
          // allow override via localStorage.hero_balance_poll_ms
          let ms = DEFAULT_POLL_MS;
          try{ const v = parseInt(localStorage.getItem('hero_balance_poll_ms')); if(v && v>=MIN_POLL_MS) ms = v; }catch(e){}
          // immediate fetch
          pollOnce();
          pollHandle = setInterval(pollOnce, ms);
        }catch(e){}
      }

      function stopPolling(){
        try{ if(pollHandle){ clearInterval(pollHandle); pollHandle = null; } }catch(e){}
      }

      async function pollOnce(){
        try{
          const hasDemo = !!localStorage.getItem('hero_token_demo');
          const hasReal = !!localStorage.getItem('hero_token_real');
          const ps = [];
          if(hasDemo) ps.push(fetchBalances('demo'));
          if(hasReal) ps.push(fetchBalances('real'));
          if(ps.length) await Promise.all(ps);
        }catch(e){}
      }

      // DOM wiring
      document.getElementById('demo-connect').addEventListener('click', async ()=>{
        const token = (document.getElementById('demo-token') || {}).value || '';
        await connectAccount(token, 'demo');
      });
      document.getElementById('real-connect').addEventListener('click', async ()=>{
        const token = (document.getElementById('real-token') || {}).value || '';
        await connectAccount(token, 'real');
      });
      document.getElementById('demo-fetch-bal').addEventListener('click', async ()=>{ await fetchBalances('demo'); });
      document.getElementById('real-fetch-bal').addEventListener('click', async ()=>{ await fetchBalances('real'); });

      // local disconnect buttons on this page
      document.getElementById('demo-disconnect').addEventListener('click', async ()=>{
        if(!confirm('Disconnect demo account?')) return;
        await disconnectMode('demo');
      });
      document.getElementById('real-disconnect').addEventListener('click', async ()=>{
        if(!confirm('Disconnect real account?')) return;
        await disconnectMode('real');
      });

      document.getElementById('done-btn').addEventListener('click', ()=>{
        // return to dashboard and flag success so dashboard can show toast
        const ret = returnTo || '/';
        // attach query param auth_done=1 so dashboard knows to pick up saved balances
        const glue = ret.indexOf('?')>=0 ? '&' : '?';
        window.location.href = ret + glue + 'auth_done=1';
      });
      document.getElementById('skip-btn').addEventListener('click', ()=>{
        // just return, no auth recorded
        const ret = returnTo || '/';
        window.location.href = ret;
      });

      // Prefill from storage if tokens exist
      document.addEventListener('DOMContentLoaded', ()=>{
        try{
          const d = localStorage.getItem('hero_token_demo');
          const r = localStorage.getItem('hero_token_real');
          if(d && document.getElementById('demo-token')) document.getElementById('demo-token').value = d;
          if(r && document.getElementById('real-token')) document.getElementById('real-token').value = r;

          // show balances if already stored
          try {
            const db = localStorage.getItem('hero_balance_demo');
            if(db) applyBalanceToUI('demo', JSON.parse(db));
            const rb = localStorage.getItem('hero_balance_real');
            if(rb) applyBalanceToUI('real', JSON.parse(rb));
          } catch(e){}
          // show disconnect buttons if tokens exist
          if(d) showDisconnectBtn('demo', true);
          if(r) showDisconnectBtn('real', true);
          // start polling if there's at least one token
          if(d || r) startPolling();
                // Query server tokens & update small status fields (so user sees server-side tokens too)
                (async function(){
                  try {
                    const r = await fetch('/control/get_tokens');
                    if(!r.ok) return;
                    const j = await r.json();
                    if(j && j.ok){
                      const ds = document.getElementById('demo-status');
                      const rs = document.getElementById('real-status');
                      if(ds) ds.textContent = j.demo_present ? ('Token ✓ ' + (j.demo_mask || '')) : (localStorage.getItem('hero_token_demo') ? 'Token (local)' : 'No token');
                      if(rs) rs.textContent = j.real_present ? ('Token ✓ ' + (j.real_mask || '')) : (localStorage.getItem('hero_token_real') ? 'Token (local)' : 'No token');
                      // show disconnect buttons if server has tokens too
                      if(j.demo_present) showDisconnectBtn('demo', true);
                      if(j.real_present) showDisconnectBtn('real', true);
                    }
                  } catch(e){}
                })();

        }catch(e){}
      });
    })();
  </script>
<script>
/*
 Robust finish helper for auth page:
  - Posts a message to opener (if present) { type:'auth_return', url: <target>, mode: <mode> }
  - Attempts to focus & close the auth tab.
  - If close is blocked, replaces the auth page body with a friendly "Done — close this tab" message and a link back.
*/
(function(){
  function _buildReturnUrl() {
    try {
      const qs = new URLSearchParams(window.location.search || '');
      const rawReturn = qs.get('return') || '/';
      let target;
      try { target = new URL(decodeURIComponent(rawReturn), window.location.origin); } catch(e) { target = new URL('/', window.location.origin); }
      target.searchParams.set('auth_done', '1');
      const mode = qs.get('mode') || (window.__hero_auth_mode || '');
      if (mode) target.searchParams.set('mode', mode);
      return target.toString();
    } catch (e) {
      return '/?auth_done=1';
    }
  }

  function finishAuth(mode) {
    try {
      // allow explicit mode override
      if (mode) window.__hero_auth_mode = mode;

      const targetUrl = _buildReturnUrl();

      // Prefer messaging to opener so opener doesn't need to reload
      if (window.opener && !window.opener.closed) {
        try {
          // only post to same-origin opener (best-effort)
          window.opener.postMessage({ type: 'auth_return', url: targetUrl, mode: (mode || window.__hero_auth_mode || '') }, window.location.origin);
          try { window.opener.focus && window.opener.focus(); } catch(e){}
        } catch (e) {
          // fallback to setting opener.location if postMessage fails (still best-effort)
          try { window.opener.location.href = targetUrl; } catch(e){}
        }
        // Try to close this tab (may be blocked depending how it was opened)
        setTimeout(function(){
          try { window.close(); } catch(e) {}
          // if still open after 250ms (close blocked), show friendly message below
          setTimeout(()=> { if (!window.closed) _replaceWithDonePage(targetUrl, mode); }, 250);
        }, 120);
        return;
      }

      // No opener -> navigate the current window back to the dashboard with auth_done
      try {
        window.location.href = targetUrl;
      } catch(e) {
        // last fallback: replace the page with a done message and link
        _replaceWithDonePage(targetUrl, mode);
      }
    } catch (e) {
      try { window.location.href = '/?auth_done=1'; } catch(e){}
    }
  }

  function _replaceWithDonePage(returnUrl, mode) {
    try {
      // Minimal accessible "done" content the user can safely close
      document.documentElement.innerHTML = '';
      document.title = 'Authentication complete';
      const wrapper = document.createElement('div');
      wrapper.style.cssText = 'font-family:system-ui,Inter,Arial;display:flex;align-items:center;justify-content:center;height:100vh;padding:20px;background:#f8fafc;color:#0f172a';
      wrapper.innerHTML = `
        <div style="max-width:740px;background:#fff;padding:18px;border-radius:10px;box-shadow:0 18px 40px rgba(2,6,23,0.06);text-align:center">
          <h2 style="margin:0 0 8px 0">Authentication complete</h2>
          <p style="margin:0 0 12px 0">You can safely close this tab. <br/>If you'd like, return to the dashboard:</p>
          <div style="display:flex;gap:8px;justify-content:center">
            <a id="returnLink" href="${returnUrl}" style="padding:8px 12px;border-radius:8px;background:#2563eb;color:#fff;text-decoration:none;font-weight:600">Return to dashboard</a>
            <button id="closeBtn" style="padding:8px 12px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:transparent;cursor:pointer">Close tab</button>
          </div>
          <p style="margin-top:8px;font-size:12px;color:#6b7280">Mode: ${mode || '—'}</p>
        </div>
      `;
      document.body.appendChild(wrapper);
      try {
        document.getElementById('closeBtn').addEventListener('click', function(){ try { window.close(); } catch(e){} });
      } catch(e){}
    } catch(e){}
  }

  // expose globally
  window.heroFinishAuth = finishAuth;

  // If page has a Done button with id 'authDoneBtn', wire it
  try {
    const btn = document.getElementById('authDoneBtn');
    if (btn) btn.addEventListener('click', function(){ finishAuth(window.__hero_auth_mode || ''); });
  } catch(e){}
})();
</script>
</body>
</html>
