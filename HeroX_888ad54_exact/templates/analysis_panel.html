<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/static/app.css">
  <title>HeroX — Analysis Panel</title>
  <style>
    :root {
      --muted: #6b7280;
      --card-bg: #fff;
      --card-border: rgba(2,6,23,0.06);
    }

    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: #f3f4f6; color:#0f172a; }
    .wrap { padding:12px; box-sizing:border-box; max-width:1200px; margin:0 auto; }

    header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    header h2 { margin:0; font-size:18px; }
    header .sub { font-size:12px; color:var(--muted); }

    /* GRID - 3 columns, visible 4 rows (rest scroll) */
    .analysis-grid-wrap { display:flex; gap:12px; }
    .analysis-grid {
      display:grid;
      grid-template-columns: repeat(3, minmax(220px, 1fr));
      grid-auto-rows: minmax(92px, auto);
      gap:12px;
      width: 100%;
      max-height: calc(92px * 4 + 12px * 3 + 12px); /* approx 4 rows visible */
      overflow:auto;
      padding:6px;
      box-sizing:border-box;
    }

    .analysis-card {
      background:var(--card-bg);
      border:1px solid var(--card-border);
      padding:10px;
      border-radius:10px;
      min-height:92px;
      display:flex;
      flex-direction:column;
      gap:8px;
      transition:box-shadow .12s, border-color .12s, transform .08s;
    }
    .analysis-card:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(2,6,23,0.04); }

    .card-head { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .card-head h4 { margin:0; font-size:14px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .card-controls { display:flex; gap:6px; align-items:center; }
    .card-controls button {
      background:transparent; border:0; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:12px;
    }

    .last10 { display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
    .last10 span { display:inline-flex; width:28px; height:28px; align-items:center; justify-content:center; border-radius:6px; border:1px solid rgba(0,0,0,0.04); font-weight:700; background:#fff; }

    .conf-badge { display:inline-block; font-weight:800; padding:4px 8px; border-radius:6px; font-size:12px; min-width:68px; text-align:center; }

    .analysis-card.prediction-active { border-color: #16a34a !important; box-shadow: 0 10px 40px rgba(16,163,93,0.12); }

    /* highest / lowest highlights */
    .analysis-card.highest { border-color: #10b981; box-shadow: 0 8px 30px rgba(16,185,129,0.06); }
    .analysis-card.lowest { border-color: #ef4444; box-shadow: 0 8px 30px rgba(239,68,68,0.06); }

    /* per-card calc area (collapsible) */
    .card-calc {
      margin-top:6px;
      background:#f9fafb;
      border:1px solid rgba(0,0,0,0.03);
      padding:8px;
      border-radius:8px;
      max-height:0;
      overflow:hidden;
      font-family: monospace;
      font-size:12px;
      white-space:pre-wrap;
      transition: max-height .18s ease, padding .18s;
    }
    .card-calc.open { max-height:220px; padding:8px; }

    .reason { font-size:12px; color:var(--muted); min-height:16px; }

    /* bottom calc panel */
    .bottom-calc {
      margin-top:14px;
      background:#fff;
      border:1px solid rgba(2,6,23,0.06);
      padding:12px;
      border-radius:10px;
      font-family: monospace;
      font-size:13px;
      white-space:pre-wrap;
      max-height:320px;
      overflow:auto;
    }

    .selected { outline: 2px solid rgba(59,130,246,0.12); box-shadow: 0 6px 20px rgba(59,130,246,0.06); }
    .muted { color:var(--muted); }

    .controls-row { display:flex; justify-content:space-between; gap:12px; align-items:center; margin-top:8px; }
    .small { font-size:12px; color:var(--muted); }

    /* summary panel (full width) */
    .summary-wrap { margin-top:12px; display:flex; gap:12px; align-items:flex-start; }
    .summary-card {
      flex: 1 1 100%;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 10px;
      padding: 12px;
    }
    .summary-title { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .summary-title h4 { margin:0; font-size:14px; }
    .summary-grid { display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; }
    .summary-item { min-width: 220px; background:#f9fafb; border-radius:8px; padding:8px; border:1px solid rgba(0,0,0,0.03); }
    .summary-table { width:100%; border-collapse:collapse; margin-top:8px; font-family:monospace; font-size:13px; }
    .summary-table th, .summary-table td { text-align:left; padding:6px 8px; border-bottom:1px dashed rgba(0,0,0,0.04); }
    .summary-top { color:#047857; font-weight:700; }
    .summary-low { color:#b91c1c; font-weight:700; }

    /* toast */
    .toast-wrap { position: fixed; right: 16px; top: 16px; z-index: 9999; display:flex; flex-direction:column; gap:8px; }
    .toast { background:#111827; color:#fff; padding:10px 14px; border-radius:8px; box-shadow:0 6px 30px rgba(2,6,23,0.2); font-size:13px; opacity:0.98; }

    @media (max-width:900px){
      .analysis-grid { grid-template-columns: repeat(2, minmax(180px, 1fr)); }
    }
    @media (max-width:600px){
      .analysis-grid { grid-template-columns: repeat(1, minmax(180px, 1fr)); }
      .summary-grid { flex-direction:column; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h2>Live Analysis — Per-market overview</h2>
        <div class="sub">Shows last-10 rolling decimals + computed confidence for each market.</div>
      </div>
      <div class="small">Click a card to select it. Use the per-card <strong>Calc</strong> button to expand inline calculations.</div>
    </header>

    <div class="analysis-grid-wrap">
      <div style="flex:1 1 100%;">
        <div id="analysisGrid" class="analysis-grid" aria-live="polite"></div>
      </div>
    </div>

    <div class="controls-row">
      <div class="small">Legend: last 10 digits (left→right oldest→newest). Confidence in badge.</div>
      <div class="small" id="selectedMarketLabel">Selected: <span class="muted">None</span></div>
    </div>

    <!-- Summary panel (new) -->
    <div class="summary-wrap" aria-live="polite">
      <div class="summary-card" id="summaryPanel">
        <div class="summary-title">
          <h4>Analysis Summary</h4>
          <div class="small" id="summaryUpdated">Waiting for data...</div>
        </div>

        <div class="summary-grid">
          <div class="summary-item" id="summaryTop">
            <div class="muted">Highest confidence</div>
            <div id="topMarket" class="summary-top">—</div>
            <div class="muted" id="topMarketDetail">—</div>
          </div>

          <div class="summary-item" id="summaryLow">
            <div class="muted">Lowest confidence</div>
            <div id="lowMarket" class="summary-low">—</div>
            <div class="muted" id="lowMarketDetail">—</div>
          </div>

          <div class="summary-item" style="flex:1 1 380px;">
            <div class="muted">Per-market top/bottom digit</div>
            <div style="max-height:160px; overflow:auto; margin-top:8px;">
              <table class="summary-table" id="perMarketTable">
                <thead><tr><th>Market</th><th>Top digit (conf)</th><th>Bottom digit (conf)</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="calcPanel" class="bottom-calc">No selection. Click a card to view its calculations here.</div>
  </div>

  <!-- toast container -->
  <div class="toast-wrap" id="toastWrap" aria-live="polite" aria-atomic="true"></div>

  <script>
// Require explicit parent handshake before auto-starting the agent.
// Add this near the top of the script in analysis_panel.html (before any auto-start logic).
(function(){
  window.__HEROPANEL_ALLOW_AUTO_START = false;
  window.__HEROPANEL_PARENT_READY = false;

  // Parent will post `{ type: 'iframe_parent_loaded', do_not_auto_start: true }`
  window.addEventListener('message', function(ev){
    try {
      if(!ev.data || typeof ev.data !== 'object') return;
      if(ev.data.type === 'iframe_parent_loaded') {
        // parent explicitly says whether it allows auto-start
        window.__HEROPANEL_PARENT_READY = true;
        window.__HEROPANEL_ALLOW_AUTO_START = !ev.data.do_not_auto_start;
        // notify iframe-local UI that the parent handshake arrived (optional)
        if(typeof window.onParentHandshake === 'function') {
          try { window.onParentHandshake(ev.data); } catch(e) {}
        }
      }
    } catch(e){}
  }, false);

  // wrap any existing auto-start call site with this helper:
  window.herox_maybe_autostart = function(startFn){
    // startFn should be the function that calls /control/start_analysis from inside the iframe
    if(window.__HEROPANEL_PARENT_READY && !window.__HEROPANEL_ALLOW_AUTO_START){
      // parent told us to NOT auto-start — do not call
      console.log('herox: parent disallowed auto-start; waiting for explicit user click inside iframe');
      return;
    }
    // otherwise allow start
    try { startFn(); } catch(e){ console.error('herox autostart error', e); }
  };

  // Very important: change any existing auto-run code in this iframe that calls start immediately on load
  // to instead call `window.herox_maybe_autostart(() => { /* original start code */ })`
  // and ensure user Start button calls the normal start logic directly (not herox_maybe_autostart).
})();
</script>

<script>
    (function(){
      try {
        // configurable minimum obs to consider computed confidence valid
        const MIN_OBS = parseInt((typeof window !== "undefined" && (window.DIFFER_ANALYZER_MIN_OBS || 4)) || 4, 10);

        // markets mapping (standalone)
        const markets = [
          { code: 'R_10', label: 'Volatility 10' },
          { code: '1HZ10V', label: 'Volatility 10 (1s)' },
          { code: 'R_25', label: 'Volatility 25' },
          { code: '1HZ25V', label: 'Volatility 25 (1s)' },
          { code: 'R_50', label: 'Volatility 50' },
          { code: '1HZ50V', label: 'Volatility 50 (1s)' },
          { code: 'R_75', label: 'Volatility 75' },
          { code: '1HZ75V', label: 'Volatility 75 (1s)' },
          { code: 'R_100', label: 'Volatility 100' },
          { code: '1HZ100V', label: 'Volatility 100 (1s)' },
          { code: 'JD10', label: 'Jump 10' },
          { code: 'JD25', label: 'Jump 25' },
          { code: 'JD50', label: 'Jump 50' },
          { code: 'JD75', label: 'Jump 75' },
          { code: 'JD100', label: 'Jump 100' },
          { code: 'RDBULL', label: 'Bull Market' },
          { code: 'RDBEAR', label: 'Bear Market' }
        ];
        const MARKET_LABELS = markets.reduce((acc,m)=>{ acc[m.code]=m.label; return acc; },{});

        const GRID = document.getElementById('analysisGrid');
        const CALC = document.getElementById('calcPanel');
        const selectedMarketLabel = document.getElementById('selectedMarketLabel');

        const summaryPanel = document.getElementById('summaryPanel');
        const topMarketEl = document.getElementById('topMarket');
        const lowMarketEl = document.getElementById('lowMarket');
        const topMarketDetail = document.getElementById('topMarketDetail');
        const lowMarketDetail = document.getElementById('lowMarketDetail');
        const perMarketTableBody = document.querySelector('#perMarketTable tbody');
        const summaryUpdated = document.getElementById('summaryUpdated');
        const toastWrap = document.getElementById('toastWrap');

        const buffers = {};
        const scores = {};
        const calcs = {};
        let selectedMarket = null;

        // storage for last panel ranking and last per-market detail (populated from SSE 'panel_ranking' or 'market_confidence')
        let latestPanelRanking = null;
        let latestMarketDetails = {}; // market -> {confidence, best_digit, per-digit scores maybe}

        function mkCard(market){
          let el = GRID.querySelector('[data-market="'+market+'"]');
          if(el) return el;
          el = document.createElement('div');
          el.className = 'analysis-card';
          el.setAttribute('data-market', market);
          const label = MARKET_LABELS[market] || market;

          // card inner html: head, last10, reason, per-card calc collapsible
          el.innerHTML = ''
            + '<div class="card-head"><h4 title="'+label+'">'+label+'</h4>'
            + '<div class="card-controls"><div class="conf-badge" aria-hidden="true">—</div>'
            + '<button class="toggle-calc" title="Toggle calc">Calc ▸</button></div></div>'
            + '<div class="last10" aria-live="polite"></div>'
            + '<div class="reason muted"></div>'
            + '<div class="card-calc" aria-hidden="true">No calculations yet.</div>';

          // click selects the market (but ignore clicks on the calc toggle)
          el.addEventListener('click', function(ev){
            if(ev.target && ev.target.classList && ev.target.classList.contains('toggle-calc')) return;
            selectMarket(market);
          });

          // calc toggle
          const toggle = el.querySelector('.toggle-calc');
          toggle.addEventListener('click', function(ev){
            ev.stopPropagation();
            const c = el.querySelector('.card-calc');
            if(c.classList.contains('open')){
              c.classList.remove('open');
              toggle.textContent = 'Calc ▸';
              c.setAttribute('aria-hidden','true');
            } else {
              c.classList.add('open');
              toggle.textContent = 'Calc ▾';
              c.setAttribute('aria-hidden','false');
              // ensure card becomes selected when expanding
              selectMarket(market);
            }
          });

          GRID.appendChild(el);
          return el;
        }

        function renderLast10Into(card, arr){
          const container = card.querySelector('.last10');
          container.innerHTML = '';
          const items = (arr || []).slice(-10);
          if(items.length === 0){
            container.textContent = '';
            return;
          }
          items.forEach(function(d){
            const sp = document.createElement('span');
            sp.textContent = (d === null || d === undefined || d === '') ? '-' : String(d);
            container.appendChild(sp);
          });
        }

        function clearPredictionHighlights(){
          GRID.querySelectorAll('.analysis-card.prediction-active').forEach(function(c){ c.classList.remove('prediction-active'); });
        }

        function clearHighestLowestHighlights(){
          GRID.querySelectorAll('.analysis-card.highest').forEach(function(c){ c.classList.remove('highest'); });
          GRID.querySelectorAll('.analysis-card.lowest').forEach(function(c){ c.classList.remove('lowest'); });
        }

        function formatConfidence(c){
          if(c === undefined || c === null) return '—';
          if (typeof c !== 'number' || isNaN(c)) return '—';
          const pct = Math.round((c||0)*10000)/100;
          return (pct).toFixed(2) + '%';
        }

        function styleBadge(badgeEl, c, bufLen){
          if(!badgeEl) return;
          // if confidence absent or buffer too small, show dash
          if(c === undefined || c === null || typeof c !== 'number' || bufLen < MIN_OBS){
            badgeEl.textContent = '—';
            badgeEl.style.background = '';
            badgeEl.style.color = '';
            return;
          }
          badgeEl.textContent = formatConfidence(c);
          let bg='#e5e7eb', color='#111';
          if(c >= 0.70){
            bg = '#16a34a'; color = '#fff';
          } else if(c >= 0.50){
            bg = '#f59e0b'; color = '#fff';
          } else {
            bg = '#e5e7eb'; color = '#111';
          }
          badgeEl.style.background = bg;
          badgeEl.style.color = color;
        }

        function markPrediction(market){
          clearPredictionHighlights();
          const el = GRID.querySelector('[data-market="'+market+'"]');
          if(el) el.classList.add('prediction-active');
        }

        function selectMarket(market){
          selectedMarket = market;
          // highlight selected card
          GRID.querySelectorAll('.analysis-card').forEach(function(c){ c.classList.remove('selected'); });
          const el = GRID.querySelector('[data-market="'+market+'"]');
          if(el) el.classList.add('selected');
          // update bottom calc panel
          const txt = calcs[market] ? (market + ': ' + JSON.stringify(calcs[market], null, 2)) : ('No calculations for ' + market);
          if(CALC) CALC.textContent = txt;
          if(selectedMarketLabel){
            const lbl = MARKET_LABELS[market] || market;
            selectedMarketLabel.innerHTML = 'Selected: <strong style="font-weight:600">'+lbl+' ('+market+')</strong>';
          }
        }

        function updateSummaryUI(){
          // build perMarket rows and compute highest/lowest from latestPanelRanking if available then fallback to latestMarketDetails
          let ranking = [];
          if(latestPanelRanking && Array.isArray(latestPanelRanking.ranking)){
            ranking = latestPanelRanking.ranking.slice();
          } else {
            // build ranking from latestMarketDetails map
            ranking = Object.keys(latestMarketDetails).map(m => ({
              market: m,
              confidence: latestMarketDetails[m].market_confidence || latestMarketDetails[m].confidence || 0
            }));
            ranking.sort((a,b)=> (b.confidence||0) - (a.confidence||0));
          }

          if(ranking.length === 0){
            topMarketEl.textContent = '—';
            topMarketDetail.textContent = '';
            lowMarketEl.textContent = '—';
            lowMarketDetail.textContent = '';
            perMarketTableBody.innerHTML = '';
            summaryUpdated.textContent = 'No panel data yet';
            return;
          }

          const top = ranking[0];
          const low = ranking[ranking.length-1];

          topMarketEl.textContent = (top.market || top.symbol || '-') + ' (' + formatConfidence(Number(top.confidence||0)) + ')';
          topMarketDetail.textContent = 'Top market — confidence ' + formatConfidence(Number(top.confidence||0));

          lowMarketEl.textContent = (low.market || low.symbol || '-') + ' (' + formatConfidence(Number(low.confidence||0)) + ')';
          lowMarketDetail.textContent = 'Lowest market — confidence ' + formatConfidence(Number(low.confidence||0));

          // per-market table
          const marketsList = (latestPanelRanking && Array.isArray(latestPanelRanking.ranking)) ? latestPanelRanking.ranking : ranking;
          // rebuild rows
          perMarketTableBody.innerHTML = '';
          marketsList.forEach(m => {
            const mk = (m.market || m.symbol || '').toString().toUpperCase();
            const tr = document.createElement('tr');

            // determine top and bottom digit info if we have counts or scores
            let topDigitText = '—';
            let bottomDigitText = '—';
            // try to use counts if present
            try {
              if(m.counts && Object.keys(m.counts).length){
                const pairs = Object.entries(m.counts).map(([k,v]) => ({d: k, c: Number(v)})).sort((a,b)=> b.c - a.c);
                const topd = pairs[0];
                const bottomd = pairs[pairs.length-1];
                topDigitText = `${topd.d} (${Math.round((topd.c/(Object.values(m.counts).reduce((a,b)=>a+b,0)||1))*10000)/100}%)`;
                bottomDigitText = `${bottomd.d} (${Math.round((bottomd.c/(Object.values(m.counts).reduce((a,b)=>a+b,0)||1))*10000)/100}%)`;
              } else if(latestMarketDetails[mk] && Array.isArray(latestMarketDetails[mk].scores)){
                const scs = latestMarketDetails[mk].scores.slice().sort((a,b)=> (b.confidence||0) - (a.confidence||0));
                if(scs.length){
                  topDigitText = (scs[0].digit!==undefined?scs[0].digit:scs[0].prediction_digit) + ' (' + formatConfidence(Number(scs[0].confidence||0)) + ')';
                  const bottom = scs[scs.length-1];
                  bottomDigitText = (bottom.digit!==undefined?bottom.digit:bottom.prediction_digit) + ' (' + formatConfidence(Number(bottom.confidence||0)) + ')';
                }
              } else if(m.best_digit !== undefined || m.best_digit !== null){
                topDigitText = (m.best_digit) + ' (' + formatConfidence(Number(m.p_best || m.confidence || 0)) + ')';
                bottomDigitText = '—';
              } else if(scores[mk]){
                topDigitText = (scores[mk].digit!==undefined?scores[mk].digit:'-') + ' (' + formatConfidence(Number(scores[mk].confidence||0)) + ')';
                bottomDigitText = '—';
              }
            } catch(e){ /* ignore */ }

            const tdMarket = document.createElement('td');
            tdMarket.textContent = mk;
            const tdTop = document.createElement('td');
            tdTop.textContent = topDigitText;
            const tdBottom = document.createElement('td');
            tdBottom.textContent = bottomDigitText;

            tr.appendChild(tdMarket);
            tr.appendChild(tdTop);
            tr.appendChild(tdBottom);
            perMarketTableBody.appendChild(tr);
          });

          // set timestamp
          const now = new Date();
          summaryUpdated.textContent = 'Updated: ' + now.toLocaleTimeString();

          // highlight highest/lowest cards
          clearHighestLowestHighlights();
          if(top && top.market){
            const elTop = GRID.querySelector('[data-market="'+(top.market).toString().toUpperCase()+'"]');
            if(elTop) elTop.classList.add('highest');
          }
          if(low && low.market){
            const elLow = GRID.querySelector('[data-market="'+(low.market).toString().toUpperCase()+'"]');
            if(elLow) elLow.classList.add('lowest');
          }
        }

        function showToast(msg, ttl=5000){
          const t = document.createElement('div');
          t.className = 'toast';
          t.textContent = msg;
          toastWrap.appendChild(t);
          setTimeout(()=> {
            try { t.style.transition = 'opacity 300ms'; t.style.opacity = '0'; } catch(e){}
          }, ttl-700);
          setTimeout(()=> { try { toastWrap.removeChild(t); } catch(e){} }, ttl);
        }

        function updateCardFromPayload(market, payload){
          try {
            // Normalize market key
            const mk = (market || '').toString().toUpperCase();
            if(!mk) return;
            const card = mkCard(mk);

            // --------- 1) Unwrap wrapper payloads (server sometimes wraps in { payload: { ... } }) ---------
            if (payload && payload.payload && typeof payload.payload === 'object') {
              payload = payload.payload;
            }

            // --------- 2) Normalize buffer_snapshot / last_decimal into local buffers map ---------
            let buffer_snapshot = [];
            if (Array.isArray(payload.buffer_snapshot)) buffer_snapshot = payload.buffer_snapshot.slice(-10);
            else if (Array.isArray(payload.buffer)) buffer_snapshot = payload.buffer.slice(-10);

            // Accept last_decimal field too (lenient)
            if (typeof payload.last_decimal !== 'undefined' && payload.last_decimal !== null) {
              // Ensure buffers[mk] exists
              buffers[mk] = (buffers[mk] || []).concat([payload.last_decimal]).slice(-10);
            } else if (buffer_snapshot.length) {
              // prefer server snapshot if present
              buffers[mk] = buffer_snapshot.slice(-10);
            } else {
              buffers[mk] = buffers[mk] || [];
            }

            // --------- 3) Normalize incoming confidence values (may come in different keys) ---------
            const rawConfCandidates = [
              payload.confidence, payload.market_confidence, payload.conf, payload.market_score && payload.market_score.confidence,
              payload.p_best, payload.p_best /* fallback */
            ];
            let payloadConf = null;
            for (const c of rawConfCandidates) {
              if (c === undefined || c === null) continue;
              const num = Number(c);
              if (!Number.isNaN(num)) { payloadConf = num; break; }
            }

            // clamp confidence to avoid 1.0 artifacts (display cap)
            const DISPLAY_CAP = 0.995;
            if (payloadConf !== null) {
              payloadConf = Math.max(0.0, Math.min(payloadConf, DISPLAY_CAP));
            }

            // --------- 4) Compute a safe computedConfidence fallback from local buffer if needed ---------
            let computedConfidence = null;
            try {
              const arr = (buffers[mk] || []).slice(-10);
              if (arr.length) {
                const freq = {};
                arr.forEach(v => { const k = (v === null || v === undefined) ? '_' : String(v); freq[k] = (freq[k]||0)+1; });
                const max = Math.max.apply(null, Object.values(freq));
                computedConfidence = (max / arr.length);
                computedConfidence = Math.max(0.0, Math.min(computedConfidence, DISPLAY_CAP));
              }
            } catch(e){ computedConfidence = null; }

            // Final confidence to display (prefer server-provided payloadConf, else computed)
            const finalConf = (payloadConf !== null && payloadConf !== undefined) ? payloadConf : (computedConfidence !== null ? computedConfidence : null);

            // --------- 5) Build/normalize scores array (prefer payload.scores; else build from counts or buffer) ---------
            let scores_list = [];
            if (Array.isArray(payload.scores) && payload.scores.length) {
              // normalize incoming scores
              scores_list = payload.scores.map(s => {
                return {
                  digit: (s.digit !== undefined ? Number(s.digit) : (s.prediction_digit !== undefined ? Number(s.prediction_digit) : null)),
                  confidence: (s.confidence !== undefined ? Number(s.confidence) : (s.p !== undefined ? Number(s.p) : 0)),
                  count: (s.count !== undefined ? Number(s.count) : 0)
                };
              }).filter(s => s.digit !== null);
            } else if (payload.counts && typeof payload.counts === 'object' && Object.keys(payload.counts).length) {
              // build from counts map
              const pairs = Object.entries(payload.counts).map(([k,v])=>({ digit: Number(k), count: Number(v) }));
              const total = pairs.reduce((a,b)=>a + (b.count||0), 0) || 1;
              scores_list = pairs.map(p => ({ digit: p.digit, confidence: (p.count / total), count: p.count }));
            } else if (Array.isArray(buffers[mk]) && buffers[mk].length) {
              // fallback: build from local buffer
              const arr = buffers[mk].slice(-10);
              const freq = {};
              arr.forEach(v => { const k = (v === null || v === undefined) ? '_' : String(v); freq[k] = (freq[k]||0)+1; });
              const pairs = Object.entries(freq).map(([k,v])=>({ digit: isNaN(Number(k)) ? k : Number(k), count: v }));
              const total = pairs.reduce((a,b)=>a + (b.count||0), 0) || 1;
              scores_list = pairs.map(p => ({ digit: p.digit, confidence: (p.count / total), count: p.count }));
            }

            // make sure confidences are numbers and clamp them
            scores_list = scores_list.map(s => {
              const conf = (s.confidence === undefined || s.confidence === null) ? 0 : Number(s.confidence);
              return { digit: Number(s.digit), confidence: Math.max(0.0, Math.min(conf, DISPLAY_CAP)), count: Number(s.count || 0) };
            });

            // sort descending by confidence
            scores_list.sort((a,b) => (b.confidence || 0) - (a.confidence || 0));

            // store canonical scores object used by UI
            if (!scores[mk]) scores[mk] = { digit: null, confidence: finalConf };
            if (scores_list.length) {
              scores[mk] = { digit: scores_list[0].digit, confidence: scores_list[0].confidence };
            } else if (finalConf !== null) {
              // keep existing digit if available, just update confidence
              scores[mk] = { digit: scores[mk].digit || null, confidence: finalConf };
            }

            // --------- 6) Keep latestMarketDetails normalized for summary & table ---------
            latestMarketDetails[mk] = latestMarketDetails[mk] || {};
            if (finalConf !== null) latestMarketDetails[mk].market_confidence = finalConf;
            if (scores_list.length) latestMarketDetails[mk].scores = scores_list.slice();
            if (payload.counts && typeof payload.counts === 'object') latestMarketDetails[mk].counts = Object.assign({}, payload.counts);

            // --------- 7) Update calcs object used by bottom panel and expand card snippet ---------
            calcs[mk] = {
              buffer: buffers[mk] ? buffers[mk].slice(-10) : [],
              computedConfidence: computedConfidence,
              rules_met_count: (payload.rules_met_count !== undefined ? payload.rules_met_count : null),
              lastPayloadSnippet: (function(){ try { const cp = Object.assign({}, payload); delete cp.buffer_snapshot; return cp; } catch(e){ return {}; } })()
            };

            // --------- 8) Render visuals: last10 digits and badge ---------
            renderLast10Into(card, buffers[mk] || []);

            const confEl = card.querySelector('.conf-badge');
            const bufLen = (buffers[mk] || []).length;

            // Use 'finalConf' (server preferred) when styling. If null, pass null so styleBadge shows dash.
            styleBadge(confEl, (finalConf !== null ? finalConf : null), bufLen);

            // Reason text: prefer payload passed reason, else message
            const reasonEl = card.querySelector('.reason');
            const rulesCount = payload.rules_met_count !== undefined ? payload.rules_met_count : (calcs[mk].rules_met_count);
            if (rulesCount !== null && rulesCount !== undefined) {
              if (payload.passed_rules && payload.passed_rules.length) {
                reasonEl.textContent = 'rules: ' + payload.passed_rules.join(', ');
              } else if (payload.reason) {
                reasonEl.textContent = payload.reason + ` (rules_met=${rulesCount})`;
              } else if (payload.message) {
                reasonEl.textContent = payload.message + ` (rules_met=${rulesCount})`;
              } else {
                reasonEl.textContent = `rules_met=${rulesCount}`;
              }
            } else if (payload.passed_rules && Array.isArray(payload.passed_rules) && payload.passed_rules.length) {
              reasonEl.textContent = 'rules: ' + payload.passed_rules.join(', ');
            } else if (payload.reason) {
              reasonEl.textContent = payload.reason;
            } else if (payload.message) {
              reasonEl.textContent = payload.message;
            } else {
              reasonEl.textContent = '';
            }

            // small snippet in expandable calc area
            try {
              const cardCalcEl = card.querySelector('.card-calc');
              const short = JSON.stringify(calcs[mk], null, 0);
              if (cardCalcEl) cardCalcEl.textContent = short || 'No calculations yet.';
            } catch(e){ /* noop */ }

            // update bottom calc if selected
            if (selectedMarket === mk && CALC) CALC.textContent = mk + ': ' + JSON.stringify(calcs[mk], null, 2);

            // --------- 9) Prediction highlight logic (unchanged) ---------
            const ae = (payload.analysis_event || '').toString().toLowerCase();
            const hasPredId = !!(payload.prediction_id || payload.pred_id || payload.predictionId);
            if(ae === 'prediction_posted' || ae === 'prediction_result' || hasPredId || payload.prediction_digit !== undefined){
              markPrediction(mk);
            }

            // --------- 10) Update summary and per-market table ---------
            updateSummaryUI();

            // debug: log the normalized payload the UI used (inspect in browser console if needed)
            console.debug('[analysis panel] normalized update', { market: mk, finalConf: finalConf, scores: scores_list, counts: payload.counts || null, buffer_len: bufLen });

          } catch(e){
            console.error('updateCardFromPayload err', e);
          }
        }



        // message handling (keeps existing behavior)
        window.addEventListener('message', function(ev){
          try {
            if(!ev.data) return;

            if(ev.data.type === 'tick'){
              const p = ev.data.payload || {};
              const market = (p.symbol || p.market || p.market_code || '').toString().toUpperCase();
              if(!market) return;
              updateCardFromPayload(market, p);
              return;
            }

            if(ev.data.type === 'analysis'){
              const p = ev.data.payload || {};
              const market = (p.market || p.symbol || '').toString().toUpperCase();
              if(market){
                updateCardFromPayload(market, p);
                return;
              }

              if(p.analysis_event && p.analysis_event.toString().toLowerCase() === 'prediction_posted' && p.market){
                // show toast and update card
                updateCardFromPayload(p.market.toString().toUpperCase(), p);
                showToast('Prediction posted: ' + (p.prediction_digit || p.prediction || '?') + ' on ' + p.market);
                return;
              }

              if(Array.isArray(p.market_scores)){
                p.market_scores.forEach(ms => {
                  const mk = (ms.market || '').toString().toUpperCase();
                  if(mk) updateCardFromPayload(mk, ms.market_score ? Object.assign({}, ms.market_score, { buffer_snapshot: ms.buffer_snapshot }) : ms);
                });
                return;
              }

              if(p.market && p.scores){
                updateCardFromPayload(p.market.toString().toUpperCase(), p);
                return;
              }
            }

            if(ev.data.type === 'init_analysis_buffer' && Array.isArray(ev.data.buffer)){
              ev.data.buffer.forEach(function(item){
                const mk = (item.market || '').toString().toUpperCase();
                if(mk) updateCardFromPayload(mk, item);
              });
            }

          } catch(e){
            // swallow
          }
        }, false);

        // SSE fallback/primary - connect directly so panel continues receiving events after reopen
        try {
          const sseUrl = (function(){
            // prefer configured env var if available via window (injected by server), otherwise /events
            try { return window.HERO_SSE_URL || '/events'; } catch(e) { return '/events'; }
          })();
          const es = new EventSource(sseUrl);
          es.addEventListener('analysis', function(ev){
            try {
              const payload = JSON.parse(ev.data || '{}');
              // analysis events can be: market_confidence, panel_ranking, prediction_posted, prediction_result etc
              const ae = (payload.analysis_event || '').toString().toLowerCase();

              // market_confidence payload contains market + confidence
              if (ae === 'market_confidence' || ae === 'market_confidence_update' || ae === 'market_confidence_changed') {
                const market = payload.market || payload.symbol || '';
                if(market) {
                  updateCardFromPayload(market.toString().toUpperCase(), payload);
                }
                return;
              }

              if (ae === 'panel_ranking') {
                // ranking will contain ranking arrays; update top markets if present
                if(Array.isArray(payload.ranking)) {
                  latestPanelRanking = payload; // store for summary
                  payload.ranking.forEach(r => {
                    const mk = (r.market || '').toString().toUpperCase();
                    if(mk) {
                      // attach counts if present in ranking object, else pass ranking entry
                      updateCardFromPayload(mk, Object.assign({}, r, { analysis_event: 'panel_ranking', buffer_snapshot: r.buffer_snapshot || [] }));
                    }
                  });
                  // update summary using latestPanelRanking
                  updateSummaryUI();
                }
                return;
              }

              // prediction events - posted / result
              if(ae === 'prediction_posted' || ae === 'prediction_result' || payload.prediction_id){
                const market = payload.market || payload.symbol || payload.market_code || '';
                if(market) {
                  updateCardFromPayload(market.toString().toUpperCase(), payload);
                }
                // show toast for prediction_posted
                if(ae === 'prediction_posted'){
                  const digit = payload.prediction_digit || payload.predicted_digit || payload.prediction || payload.prediction_digit;
                  showToast('Prediction posted: ' + (digit!==undefined?digit:'?') + ' on ' + (payload.market || payload.symbol || ''));
                }
                return;
              }

              // fallback: if payload contains market or symbol, update
              const fallbackMarket = payload.market || payload.symbol || payload.market_code || null;
              if(fallbackMarket) updateCardFromPayload(String(fallbackMarket).toUpperCase(), payload);

            } catch(err) {
              // ignore
            }
          });

          // handle default/message events (data frames without explicit 'event: ...')
          es.addEventListener('message', function(ev) {
            try {
              if (!ev || !ev.data) return;
              const obj = JSON.parse(ev.data || '{}');
              // The server may send { "payload": { ... } } or the payload directly.
              const payload = obj.payload || obj;
              if (!payload) return;
              // determine market/symbol from payload and update UI
              const market = payload.market || payload.symbol || payload.market_code || null;
              if (market) {
                updateCardFromPayload(String(market).toUpperCase(), payload);
              } else {
                // fallback: try older array-style payload (legacy)
                if (Array.isArray(payload) && payload.length >= 7) {
                  const possibleSym = payload[6];
                  if (possibleSym) updateCardFromPayload(String(possibleSym).toUpperCase(), payload);
                }
              }
            } catch (e) {
              // ignore parse errors
            }
          });

          // silently ignore ES errors (we will still receive postMessage updates if provided)
          es.addEventListener('error', function(){});
        } catch(e){
          // EventSource not available or blocked — rely on postMessage path
        }

        // initial render: create cards for known markets (keeps original set)
        (function init(){
          markets.forEach(m => mkCard((m.code||'').toString().toUpperCase()));
        })();

      } catch(e){
        console.error('analysis panel boot err', e);
      }
    })();
  </script>
</body>
</html>
