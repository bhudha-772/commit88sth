<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>HeroX — Markets</title>
  <style>
    :root { --bg: #fff; }
    body { margin: 0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; }
    .wrap{max-width:1280px;margin:18px auto;padding:16px;box-sizing:border-box}
    header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
    h1{margin:0;font-size:20px}
    .top-controls { display:flex; gap:10px; align-items:center; }
    .status-pill { padding:6px 10px; border-radius:999px; font-weight:700; font-size:12px; background:rgba(2,6,23,0.04); color:var(--muted); }
    .market-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px}
    .market-tile{background:linear-gradient(180deg,#fff,#f8fafc);padding:12px;border-radius:12px;border:1px solid rgba(2,6,23,0.04);cursor:pointer;display:flex;flex-direction:column;gap:8px;min-height:110px;transition:transform .12s,box-shadow .12s;position:relative;overflow:visible}
    .market-tile:hover{transform:translateY(-6px);box-shadow:0 18px 36px rgba(2,6,23,0.06)}
    .market-title{font-weight:800;font-size:15px;color:#0f172a}
    .market-sub{color:var(--muted,#6b7280);font-size:13px}
    .market-meta { display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:6px; }
    .market-stats { display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }
    .market-dot { width:12px;height:12px;border-radius:999px;background:#d1d5db; box-shadow:inset 0 -1px 0 rgba(0,0,0,0.06); transition: all .18s; }
    .market-dot.running { background: #16a34a; box-shadow: 0 4px 12px rgba(16,163,93,0.18); }
    .market-lastdigit { font-weight:800; font-size:18px; width:44px; height:44px; display:flex; align-items:center; justify-content:center; border-radius:8px; background:#fff; border:1px solid rgba(2,6,23,0.04); }
    .market-small { font-size:12px; color:var(--muted); }

    /* header balance cards */
    .balances-container { display:flex; gap:8px; align-items:center; margin-right:12px; }
    .header-balance-card{display:inline-flex;flex-direction:column;align-items:center;justify-content:center;padding:6px 12px;border-radius:8px;background:#f3f4f6;color:#111827;font-weight:600;font-size:13px;margin-left:8px;min-width:110px;text-align:center}
    .header-balance-card .balance-amount{font-size:14px;font-weight:700}
    .header-balance-card .balance-meta{font-size:11px;color:var(--muted);margin-top:4px}

    /* overlay that will host the full dashboard DOM */
    .overlay {
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1600;
      background: rgba(10,15,20,0.45);
      padding:20px;
    }
    .overlay.visible{display:flex}
    .overlay .inner {
      width: min(1200px, 98%); height: min(92vh, 1100px);
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(248,250,252,0.98));
      border-radius:14px;padding:12px;overflow:auto;box-shadow:0 30px 80px rgba(2,6,23,0.3);border:1px solid rgba(2,6,23,0.06);
      box-sizing: border-box;
    }
    .overlay .close { float:right; cursor:pointer; border-radius:8px; padding:6px 10px; border:1px solid rgba(2,6,23,0.06); background:transparent }

    /* small modal chooser */
    .modal-chooser {
      position: fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      z-index: 2000; background: #fff; border-radius:12px; padding:16px; box-shadow:0 20px 60px rgba(2,6,23,0.3);
      border:1px solid rgba(2,6,23,0.06); width: 420px; max-width: 96%;
      display:none;
    }
    .modal-chooser.visible { display:block; }
    .modal-chooser h4 { margin:0 0 10px 0; font-size:16px; }
    .chooser-row { display:flex; gap:8px; align-items:center; margin:8px 0; }
    .chooser-actions { display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }

    .chooser-list { max-height: 220px; overflow:auto; border:1px solid rgba(2,6,23,0.04); padding:8px; border-radius:8px; }
    .chooser-item { display:flex; align-items:center; gap:12px; padding:6px 4px; }

    /* analysis start prompt (small) */
    .analysis-prompt {
      position: fixed; right: 18px; bottom: 18px; z-index:2200; background:#fff; border-radius:10px; padding:12px; box-shadow:0 12px 36px rgba(2,6,23,0.16); border:1px solid rgba(2,6,23,0.06);
      display:none; width:320px;
    }
    .analysis-prompt.visible { display:block; }
    .analysis-prompt h4 { margin:0 0 8px 0; font-size:14px; }
    .analysis-prompt .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }

    .analysis-quickbtn {
      border:0;background:transparent;color:var(--muted);cursor:pointer;font-size:13px;padding:6px 8px;border-radius:6px;
    }

    /* analysis panel card styles inside iframe (kept small and portable) */
    .analysis-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:10px; }
    .analysis-card { background:#fff;border:1px solid rgba(2,6,23,0.06);padding:10px;border-radius:10px; min-height:92px; display:flex; flex-direction:column; gap:6px; transition:box-shadow .12s, border-color .12s; }
    .analysis-card h4 { margin:0;font-size:14px }
    .last10-box { display:flex; gap:6px; flex-wrap:wrap }
    .last10-box span { display:inline-flex; width:28px; height:28px; align-items:center; justify-content:center; border-radius:6px; border:1px solid rgba(0,0,0,0.04); font-weight:700 }

    /* highlight predicted card */
    .analysis-card.prediction-active { border-color: #16a34a !important; box-shadow: 0 10px 40px rgba(16,163,93,0.12); }

    /* floating icons */
    .floating-action {
      position: fixed; right: 18px; bottom: 140px; z-index:2400; width:48px;height:48px;border-radius:12px;background:#fff;box-shadow:0 12px 36px rgba(2,6,23,0.12);display:flex;align-items:center;justify-content:center;border:1px solid rgba(2,6,23,0.06);cursor:pointer;
    }
    .floating-action.small { width:44px;height:44px;border-radius:10px;bottom:200px; }
    .floating-action svg { width:22px;height:22px; }

    @media (max-width:980px){ .market-grid{grid-template-columns:repeat(auto-fit,minmax(180px,1fr))} .overlay .inner{padding:8px} .modal-chooser{width:92%} .analysis-prompt{width:92%;right:4%;left:4%} }

    /* full-dashboard layout elements (kept inside iframe) */
    .panel { background:#fff;border-radius:10px;padding:12px;border:1px solid rgba(2,6,23,0.06); box-shadow:0 10px 30px rgba(2,6,23,0.04); }
    .panel-header { display:flex;justify-content:space-between;align-items:center;margin-bottom:8px; gap:12px; }
    .panel-body { padding-top:8px; }

    /* Global fixed raw debug (right side) */
    #globalRawDebug {
      position: fixed;
      right: 12px;
      top: 80px;
      width: 360px;
      max-width: calc(100% - 36px);
      height: calc(70vh);
      background: #0b1220;
      color: #e6eef8;
      border-radius: 10px;
      padding: 10px;
      overflow: auto;
      box-shadow: 0 30px 80px rgba(2,6,23,0.35);
      z-index: 4000;
      font-family: monospace;
      font-size: 12px;
    }
    #globalRawDebug h4 { margin:0 0 8px 0; font-size:13px; color:#bcd4ff; font-weight:700 }
    .raw-line { margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid rgba(255,255,255,0.03); word-break:break-word; color:#e6eef8 }
    .raw-time { color:#8ea7e6; font-size:11px; margin-bottom:4px; display:block }
    .raw-msg { color:#dbeafe; font-size:12px }
    .raw-debug-actions { display:flex; gap:8px; margin-bottom:8px }
    .raw-debug-actions button { padding:6px 8px; border-radius:6px; border:0; cursor:pointer; background:#111827; color:#fff; font-weight:600 }
  /* Move any universal raw-debug out of the way: fixed bottom-right, scrollable */
  .raw-debug {
    position: fixed !important;
    right: 18px !important;
    bottom: 18px !important;
    width: 360px !important;
    max-height: 40vh !important;
    overflow: auto !important;
    z-index: 99998 !important;
    background: rgba(255,255,255,0.98);
    border: 1px solid rgba(0,0,0,0.06);
    border-radius: 8px;
    padding: 8px;
    box-shadow: 0 12px 36px rgba(2,6,23,0.12);
    font-family: monospace;
    font-size: 12px;
  }
  </style>
 <link rel="stylesheet" href="/static/app.css"> 
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>HeroX — Markets (click tiles to expand • choose markets in the chooser)</h1>
        <div style="font-size:13px;color:var(--muted);margin-top:6px">To select markets: click <strong>Start Deriv → Custom</strong>, then tick the markets. Clicking a tile opens the full dashboard overlay.</div>
      </div>

      <div class="top-controls">
        <div id="balancesWrap" style="display:flex;align-items:center">
          <!-- balances container (injected) -->
        </div>

        <div id="derivStatus" class="status-pill">Deriv: stopped</div>
        <div id="analysisStatus" class="status-pill">Analysis: stopped</div>

        <button id="btnToggleBalances" class="btn" title="Toggle balances">Toggle Balances</button>
        <button id="btnStartDeriv" class="btn btn-glow">Start Deriv</button>
        <button id="btnStartAnalysis" class="btn btn-glow">Start Analysis</button>
        

      </div>

      <button id="journal-header-btn" title="Open Prediction Journal" aria-label="Open Prediction Journal" class="header-btn">
        <!-- small book icon -->
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="4" width="14" height="16" rx="1.2" stroke="currentColor" stroke-width="1.2" fill="none"/>
          <path d="M5 6h11" stroke="currentColor" stroke-width="1" stroke-linecap="round"/>
          <path d="M19 5.5a1 1 0 011 1v11a1 1 0 01-1 1h-2" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>

      <a href="/charts" style="margin-left:8px">Charts</a>
    </header>

    <section id="marketGrid" class="market-grid" aria-live="polite"></section>

    <div style="margin-top:14px;color:var(--muted)">Note: Autotrade panel and balance cards removed from expanded view per request.</div>
  </div>

  <!-- Start Deriv chooser modal (small) -->
  <div id="derivChooser" class="modal-chooser" role="dialog" aria-hidden="true" aria-modal="true">
    <h4>Start Deriv — choose scope</h4>

    <div class="chooser-row">
      <label><input type="radio" name="deriv_scope" value="all" checked> All markets</label>
      <label style="margin-left:16px"><input type="radio" name="deriv_scope" value="custom"> Custom selection</label>
    </div>

    <div id="chooserCustomRow" style="margin-top:8px;display:none">
      <div style="font-size:13px;color:var(--muted);margin-bottom:8px">Tick the markets you want to start</div>
      <div class="chooser-list" id="chooserList"></div>
    </div>

    <div class="chooser-actions">
      <button id="chooserCancel" class="btn">Cancel</button>
      <button id="chooserStart" class="btn btn-glow">Start</button>
    </div>
  </div>

  <!-- Overlay container with iframe for isolation -->
  <div id="dashboardOverlay" class="overlay" aria-hidden="true" role="dialog">
    <div class="inner" id="overlayInner" role="document" aria-label="Expanded Dashboard area">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div id="overlayHeaderTitle" style="font-weight:800;font-size:16px">Market</div>
        <div>
          <button id="closeOverlayBtn" class="close">Close</button>
        </div>
      </div>
      <!-- isolated iframe — app.js runs here and cannot touch parent DOM -->
      <iframe id="overlayFrame" title="Expanded dashboard" style="width:100%;height:calc(100% - 36px);border:0;border-radius:8px;background:white"></iframe>
    </div>
  </div>

  <div id="autotrade-container"></div>

  <!-- Template containing the full original dashboard markup (kept intact) -->
  <template id="fullDashboardTemplate">
    <div class="app" id="app">
      <header>
        <div>
          <h1>HeroX — Live Ticks & Adaptive Analysis</h1>
          <div style="font-size:12px;color:var(--muted);margin-top:6px;">White background UI • Analysis reads <strong>last_decimal</strong> only (not last_unit)</div>
        </div>
        <div class="controls">
          <div id="derivStatus_inner" class="status-pill">Deriv: stopped</div>
          <div id="analysisStatus_inner" class="status-pill">Analysis: stopped</div>
        </div>

        <!-- prediction produced counter (badge) -->
        <div id="prediction-counter" style="display:inline-block; margin-left:12px;">
          <span style="font-weight:600">Predictions:</span>
          <span id="prediction-count" aria-live="polite">0</span>
        </div>

        <!-- toast container -->
        <div id="toast-container" style="position:fixed; right:16px; top:16px; z-index:9999; display:flex; flex-direction:column; gap:8px; pointer-events:none;"></div>

      </header>

      <div class="col-tick" style="margin-top:12px">
        <div class="panel" id="tickPanel">
          <div class="panel-header">
            <h3>Tick Panel — last 10 digits</h3>
            <div style="display:flex;align-items:center;gap:8px;">
              <button id="btnClearTicks" class="btn">Clear Ticks</button>
              <button id="btnToggleTickList" class="btn">Expand</button>
              <span class="muted" id="tickCount">0 ticks</span>
            </div>
          </div>

          <div class="panel-body">
            <div class="tick-scroll">
              <div class="tick-grid" id="last10Container" aria-live="polite"></div>
            </div>

            <div class="tick-meta" id="tickMeta">
              <span>Buffer (displaying last 10 digits in-panel) • Source: server ticks (last_decimal)</span>
            </div>

            <div class="tick-list" id="tickList" aria-live="polite" title="Recent ticks (scroll)"></div>
          </div>
        </div>
      </div>

      <div class="col-analysis" style="margin-top:12px">
        <div class="panel" id="analysisPanel">
          <div class="panel-header">
            <h3>Analysis Panel</h3>
            <div style="display:flex;align-items:center;gap:10px">
              <div class="muted">Buffer size: <strong id="analysisBufferSize">0</strong></div>
              <div class="status-pill">Min required: <strong>35</strong></div>
              <div style="width:14px"></div>
              <div style="font-size:13px;color:var(--muted)">Entropy / Confidence / SimWin</div>
            </div>

            <div style="display:flex;gap:8px;align-items:center">
              <button id="btnClearAnalysis" class="btn">Clear Analysis</button>
            </div>
          </div>

          <div class="panel-body">
            <div class="main-content" style="flex:1 1 auto; overflow:auto; min-height:0; padding-top:12px;">
              <div class="panel-subheader" style="display:flex;justify-content:space-between;align-items:center">
                <h4 style="margin:0;font-size:13px">Digits 0–9 (cursor points to last decimal)</h4>
                <div class="muted">Current last decimal is highlighted (only when analysis is running)</div>
              </div>

              <div style="margin-top:12px" class="digits-grid" id="digitsGrid"></div>

              <div style="margin-top:14px; display:flex;justify-content:space-between;align-items:center">
                <h4 style="margin:0;font-size:13px">Rolling Buffer (last 35 digits)</h4>
                <div class="muted" id="bufferMeta">Showing up to 35 most recent last_decimal values</div>
              </div>

              <div class="buffer-list" id="bufferList" style="margin-top:8px;"></div>

              <div style="margin-top:12px" id="analysisStatusText" class="muted">Idle</div>
            </div>
          </div>
        </div>
      </div>

      <!-- RAW debug inside iframe retained (so overlay still has internal debug) -->
      <div class="small-row" style="margin-top:12px">
        <div class="panel" id="rawPanel">
          <div class="panel-header">
            <h3>Raw Debug (overlay)</h3>
            <div class="muted">Event stream & analysis payloads (overlay-local)</div>
          </div>
          <div class="panel-body">
            <div class="raw-debug" id="rawDebug">SSE: connecting…</div>
            <div style="margin-top:8px"><button id="btnClearRaw" class="btn">Clear Raw</button></div>
          </div>
        </div>

        <div class="panel" id="controlsStatusPanel" style="margin-left:12px">
          <div class="panel-header">
            <h3>Controls & Live Status</h3>
            <div class="muted">Quick controls & heartbeat</div>
          </div>
          <div class="panel-body" style="gap:8px">
            <div style="display:flex;gap:10px;margin-bottom:10px">
              <button id="btnManualPredict" class="btn btn-success">Manual Predict (test)</button>
              <button id="btnSimTick" class="btn">Simulate Tick</button>
            </div>

            <div style="font-size:13px;color:var(--muted);margin-bottom:8px">
              Use Start Deriv to start tick worker which posts ticks to the server. Use Start Analysis to run the adaptive analysis agent.
            </div>

            <div class="col" style="gap:6px">
              <div class="row"><div class="muted">SSE:</div> <div id="sseState" class="count-bubble">connecting</div></div>
              <div class="row"><div class="muted">Latest analysis event:</div> <div id="latestAnalysis" class="status-pill">—</div></div>
              <div class="row"><div class="muted">Last tick digit:</div> <div id="latestTickDigit" class="status-pill">—</div></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </template>


  <script>
    (function(){
      const markets = [
        { code: 'R_10', label: 'Volatility 10' },
        { code: '1HZ10V', label: 'Volatility 10 (1s)' },
        { code: 'R_25', label: 'Volatility 25' },
        { code: '1HZ25V', label: 'Volatility 25 (1s)' },
        { code: 'R_50', label: 'Volatility 50' },
        { code: '1HZ50V', label: 'Volatility 50 (1s)' },
        { code: 'R_75', label: 'Volatility 75' },
        { code: '1HZ75V', label: 'Volatility 75 (1s)' },
        { code: 'R_100', label: 'Volatility 100' },
        { code: '1HZ100V', label: 'Volatility 100 (1s)' },
        { code: 'JD10', label: 'Jump 10' },
        { code: 'JD25', label: 'Jump 25' },
        { code: 'JD50', label: 'Jump 50' },
        { code: 'JD75', label: 'Jump 75' },
        { code: 'JD100', label: 'Jump 100' },
        { code: 'RDBULL', label: 'Bull Market' },
        { code: 'RDBEAR', label: 'Bear Market' }
      ];

      const grid = document.getElementById('marketGrid');
      const chooser = document.getElementById('derivChooser');
      const chooserCustomRow = document.getElementById('chooserCustomRow');
      const chooserList = document.getElementById('chooserList');

      // NOTE: analysis prompt and quick button removed per request
      // const analysisPrompt = document.getElementById('analysisPrompt');
      // const analysisNotNow = document.getElementById('analysisNotNow');
      // const analysisTakeMe = document.getElementById('analysisTakeMe');
      // const analysisQuickBtn = document.getElementById('analysisQuickBtn');

      // balance helpers (robust, tolerant to different shapes)
      (function(){
        const containerWrap = document.getElementById('balancesWrap');

        // Polling defaults (ms). Default 850ms. Config via localStorage.hero_balance_poll_ms. Minimum 250ms.
        const DEFAULT_POLL_MS = 850;
        const MIN_POLL_MS = 250;
        let __idx_balance_poll_handle = null;
        let __idx_balance_poll_running = false;
        let __idx_balance_poll_inflight = false;

        function parseBalanceObj(obj){
          if(obj === null || obj === undefined) return null;
          if(typeof obj === 'number') return { amount: obj, currency: '' };
          // common shapes
          if(typeof obj === 'object'){
            if(obj.amount !== undefined) return { amount: obj.amount, currency: obj.currency || '' };
            if(obj.balance !== undefined && typeof obj.balance !== 'object') return { amount: obj.balance, currency: obj.currency || obj.currency_code || '' };
            if(obj.balance && typeof obj.balance === 'object' && obj.balance.balance !== undefined) {
              return { amount: obj.balance.balance, currency: obj.balance.currency || '', loginid: obj.balance.loginid || obj.balance.login_id || '' };
            }
            // sometimes API returns { balances: { demo: 100, real: 12 } or similar
            if(obj.balances && typeof obj.balances === 'object') {
              // caller should normalize; fallback
              const keys = Object.keys(obj.balances);
              if(keys.length) return { amount: obj.balances[keys[0]], currency: '' };
            }
            // fallback string-ish
            return { amount: (obj.amount || obj.balance || ''), currency: obj.currency || '' };
          }
          // fallback: string
          return { amount: String(obj), currency: '' };
        }

        function createCard(id, label){
          const card = document.createElement('div');
          card.className = 'header-balance-card';
          card.id = id;
          card.innerHTML = `<div style="font-size:11px;color:#6b7280">${label}</div><div class="balance-amount">—</div><div class="balance-meta"> </div>`;
          return card;
        }

        function applyToDOM(mode, obj){
          try {
            const id = (mode==='real') ? 'header-real-balance' : 'header-demo-balance';
            let card = document.getElementById(id);
            if(!card){
              card = createCard(id, mode === 'real' ? 'Real' : 'Demo');
              containerWrap.appendChild(card);
            }
            const parsed = parseBalanceObj(obj) || { amount: '—', currency: '' };
            const amt = parsed.amount === null || parsed.amount === undefined || parsed.amount === '' ? '—' : (typeof parsed.amount === 'number' ? parsed.amount.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : String(parsed.amount));
            const metaText = parsed.loginid ? (parsed.currency ? parsed.currency + ' • ' + parsed.loginid : parsed.loginid) : (parsed.currency || '');
            const amtEl = card.querySelector('.balance-amount');
            const metaEl = card.querySelector('.balance-meta');
            if(amtEl) amtEl.textContent = amt;
            if(metaEl) metaEl.textContent = metaText;
          } catch(e){ console.warn('applyToDOM err', e); }
        }

        function loadSavedBalances(){
          try {
            const demoRaw = localStorage.getItem('hero_balance_demo');
            const realRaw = localStorage.getItem('hero_balance_real');
            if(demoRaw) { try { applyToDOM('demo', JSON.parse(demoRaw)); } catch(e) { applyToDOM('demo', demoRaw); } }
            if(realRaw) { try { applyToDOM('real', JSON.parse(realRaw)); } catch(e) { applyToDOM('real', realRaw); } }
          } catch(e){}
        }

        // network helper: fetch balance for a single mode and persist/apply
        async function fetchBalancesForMode(mode){
          try{
            const url = '/control/get_balances?mode=' + encodeURIComponent(mode);
            const r = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
            if(!r.ok){
              // Silently ignore non-OK; return null
              return null;
            }
            const j = await r.json().catch(()=>null);
            if(!j) return null;
            // prefer nested shapes
            const obj = j.balance || j.balances || j;
            try { localStorage.setItem('hero_balance_' + mode, JSON.stringify(obj)); } catch(e){}
            applyToDOM(mode, obj);
            return obj;
          }catch(e){
            // ignore errors
            return null;
          }
        }

        // single poll iteration: fetch demo+real (if tokens present) without overlapping inflight requests
        async function pollBalancesOnce(){
          try{
            if (__idx_balance_poll_inflight) return;
            __idx_balance_poll_inflight = true;

            const hasDemo = !!localStorage.getItem('hero_token_demo');
            const hasReal = !!localStorage.getItem('hero_token_real');

            const promises = [];
            if(hasDemo) promises.push(fetchBalancesForMode('demo'));
            if(hasReal) promises.push(fetchBalancesForMode('real'));
            if(promises.length === 0){
              // if no local tokens, try to rely on server tokens? still do nothing.
            } else {
              await Promise.all(promises);
            }
          } catch(e){
            // ignore
          } finally {
            __idx_balance_poll_inflight = false;
          }
        }

        // start/stop polling controls (exposed globally under __idx*)
        function startHeaderBalancePolling(){
          try{
            if(__idx_balance_poll_running) return;
            let ms = DEFAULT_POLL_MS;
            try{
              const v = parseInt(localStorage.getItem('hero_balance_poll_ms'));
              if(v && Number.isFinite(v) && v >= MIN_POLL_MS) ms = v;
            }catch(e){}
            __idx_balance_poll_running = true;
            // immediate poll
            pollBalancesOnce().catch(()=>{});
            __idx_balance_poll_handle = setInterval(()=> {
              pollBalancesOnce().catch(()=>{});
            }, ms);
            window.__idx_start_balance_polling = startHeaderBalancePolling;
            window.__idx_stop_balance_polling = stopHeaderBalancePolling;
            console.debug('Header balance polling started, interval=' + ms + 'ms');
          }catch(e){}
        }
        function stopHeaderBalancePolling(){
          try{
            if(__idx_balance_poll_handle){
              clearInterval(__idx_balance_poll_handle);
              __idx_balance_poll_handle = null;
            }
            __idx_balance_poll_running = false;
            console.debug('Header balance polling stopped');
          }catch(e){}
        }

        // toggle behavior
        const toggleBtn = document.getElementById('btnToggleBalances');
        let balancesVisible = true;
        toggleBtn.addEventListener('click', ()=> {
          balancesVisible = !balancesVisible;
          const wrap = document.getElementById('balancesWrap');
          if(wrap) wrap.style.display = balancesVisible ? 'flex' : 'none';
        });

        // expose API for auth modal or external scripts
        window.onAuthSuccess = function(authData){
          try {
            if(!authData) return;
            const bal = authData.balances || authData.balance || (authData.balances ? authData.balances : {});
            if(authData.balances && typeof authData.balances === 'object' && ('demo' in authData.balances || 'real' in authData.balances)){
              if('demo' in authData.balances) localStorage.setItem('hero_balance_demo', JSON.stringify({amount: authData.balances.demo}));
              if('real' in authData.balances) localStorage.setItem('hero_balance_real', JSON.stringify({amount: authData.balances.real}));
            } else {
              if(authData.demo_balance || authData.demo) try { localStorage.setItem('hero_balance_demo', JSON.stringify(authData.demo_balance || authData.demo)); } catch(e){}
              if(authData.real_balance || authData.real) try { localStorage.setItem('hero_balance_real', JSON.stringify(authData.real_balance || authData.real)); } catch(e){}
            }
            if(authData.balance) try { localStorage.setItem('hero_balance_' + (authData.mode || 'demo'), JSON.stringify(authData.balance)); } catch(e){}
            loadSavedBalances();
            // start header polling when authenticated
            try { startHeaderBalancePolling(); } catch(e){}
          } catch(e){ console.warn('onAuthSuccess err', e); }
        };

        // quick public refresh
        window.__hero_apply_saved_balances = function(){ loadSavedBalances(); };

        // init load
        loadSavedBalances();

        // If there are tokens in localStorage start polling immediately
        try {
          const hasDemo = !!localStorage.getItem('hero_token_demo');
          const hasReal = !!localStorage.getItem('hero_token_real');
          if(hasDemo || hasReal) {
            // slight delay so DOM settles
            setTimeout(()=> { startHeaderBalancePolling(); }, 220);
          }
        } catch(e){}

        // keep header cards updated when localStorage changes from other tabs
        window.addEventListener('storage', function(e){
          if(!e) return;
          if(e.key && (e.key.startsWith('hero_token_') || e.key.startsWith('hero_balance_'))){
            loadSavedBalances();
            try {
              // start polling if tokens were added
              const hasDemo = !!localStorage.getItem('hero_token_demo');
              const hasReal = !!localStorage.getItem('hero_token_real');
              if(hasDemo || hasReal) startHeaderBalancePolling();
              else stopHeaderBalancePolling();
            } catch(e){}
          }
        });

      })();

      // floating analysis icon (persistent access) — visible on load, single click handler
      const analysisIcon = document.createElement('div');
      analysisIcon.className = 'floating-action';
      analysisIcon.title = 'Open Analysis';
      analysisIcon.setAttribute('role', 'button');
      analysisIcon.setAttribute('aria-label', 'Open Analysis Panel');
      analysisIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="#0f172a" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="M7 13v6"/><path d="M12 9v10"/><path d="M17 5v14"/></svg>';

      // visible by default
      analysisIcon.style.display = '';

      // attach click handler once (ensure openAnalysisPanel exists later)
      analysisIcon.addEventListener('click', function (ev) {
        try {
          if (typeof openAnalysisPanel === 'function') {
            openAnalysisPanel();
          } else {
            const quick = document.getElementById('analysisQuickBtn');
            if (quick) quick.style.display = '';
          }
        } catch (e) {
          console.warn('analysisIcon click handler error', e);
        }
      });

      document.body.appendChild(analysisIcon);


      // journal removed; keep only essential controls for modal chooser / SSE
      const chooserSelected = new Set();
      let runningSymbols = new Set();
      let overlaySymbol = null;
      const tilesByCode = new Map();

      // Global raw debug (parent-level) helpers
      function appendGlobalRaw(payload, label){
        try {
          const container = document.getElementById('globalRawDebug');
          if(!container) return;
          const wrapper = document.createElement('div');
          wrapper.className = 'raw-line';
          const ts = new Date().toLocaleTimeString();
          const title = document.createElement('div');
          title.className = 'raw-time';
          title.textContent = `${ts} ${label ? '• ' + label : ''}`;
          const body = document.createElement('div');
          body.className = 'raw-msg';
          try { body.textContent = (typeof payload === 'string') ? payload : JSON.stringify(payload); } catch(e) { body.textContent = String(payload); }
          wrapper.appendChild(title);
          wrapper.appendChild(body);
          container.appendChild(wrapper);
          // keep scroll at bottom
          container.scrollTop = container.scrollHeight;
        } catch(e){}
      }
      // create the global raw debug element (if not already present)
      (function createRawDebugWidget(){
        if(document.getElementById('heroRawToggle')) return;

        // styles appended (keeps everything local)
        const style = document.createElement('style');
        style.textContent = `
          .raw-toggle {
            position: fixed;
            right: 18px;
            bottom: 18px;
            width: 46px;
            height: 46px;
            border-radius: 10px;
            background: #0f172a;
            color: white;
            display:flex;
            align-items:center;
            justify-content:center;
            z-index: 99999;
            box-shadow: 0 12px 36px rgba(2,6,23,0.12);
            cursor:pointer;
            border: none;
          }
          .raw-panel-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            z-index: 99998;
            display: none;
            align-items: flex-end;
            justify-content: flex-end;
            padding: 12px;
          }
          .raw-panel {
            width: min(560px, 96%);
            max-height: 60vh;
            background: #071025;
            color: #e6eef8;
            border-radius: 10px;
            overflow: auto;
            box-shadow: 0 30px 80px rgba(2,6,23,0.45);
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.03);
            font-family: monospace;
            font-size: 12px;
          }
          .raw-panel .raw-actions { display:flex; gap:8px; margin-bottom:8px; }
          .raw-panel .raw-actions button { padding:6px 8px; border-radius:6px; border:0; cursor:pointer; background:#0b1220; color:#fff; font-weight:600 }
          .raw-line { margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid rgba(255,255,255,0.03); word-break:break-word; color:#e6eef8 }
          .raw-time { color:#8ea7e6; font-size:11px; margin-bottom:4px; display:block }
          .raw-msg { color:#dbeafe; font-size:12px }
        `;
        document.head.appendChild(style);

        // toggle button
        const btn = document.createElement('button');
        btn.id = 'heroRawToggle';
        btn.className = 'raw-toggle';
        btn.title = 'Open debug';
        btn.innerHTML = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="white" stroke-width="1.6"><path d="M3 7h18M3 12h18M3 17h18"/></svg>';
        document.body.appendChild(btn);

        // backdrop + panel
        const backdrop = document.createElement('div');
        backdrop.className = 'raw-panel-backdrop';
        backdrop.id = 'heroRawBackdrop';
        backdrop.setAttribute('aria-hidden', 'true');

        const panel = document.createElement('div');
        panel.className = 'raw-panel';
        panel.id = 'heroRawPanel';
        panel.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:800">Universal Raw Debug</div>
            <div><button id="heroRawClose" style="background:transparent;border:0;color:#fff;cursor:pointer">✕</button></div>
          </div>
          <div class="raw-actions"><button id="heroRawClear">Clear</button><button id="heroRawCollapse">Collapse</button></div>
          <div id="heroRawBody" aria-live="polite"></div>
        `;
        backdrop.appendChild(panel);
        document.body.appendChild(backdrop);

        // handlers
        function openPanel(){
          backdrop.style.display = 'flex';
          backdrop.setAttribute('aria-hidden','false');
          // ensure scroll at bottom
          const body = document.getElementById('heroRawBody');
          if(body) body.scrollTop = body.scrollHeight;
        }
        function closePanel(){
          backdrop.style.display = 'none';
          backdrop.setAttribute('aria-hidden','true');
        }

        btn.addEventListener('click', function(ev){ ev.stopPropagation(); openPanel(); });
        document.getElementById('heroRawClose').addEventListener('click', closePanel);
        document.getElementById('heroRawCollapse').addEventListener('click', closePanel);
        document.getElementById('heroRawClear').addEventListener('click', function(){
          const b = document.getElementById('heroRawBody'); if(b) b.innerHTML = '';
        });

        // click outside closes panel
        backdrop.addEventListener('click', function(ev){
          if(ev.target === backdrop) closePanel();
        });

        // click anywhere else on document closes if open (except clicks on toggle)
        document.addEventListener('click', function(ev){
          const isOpen = backdrop.style.display === 'flex';
          if(!isOpen) return;
          const target = ev.target;
          if(target === btn || backdrop.contains(target)) return;
          closePanel();
        }, true);

        // expose appendGlobalRaw (override previous) to append to this new panel body
        window.appendGlobalRaw = function(payload, label){
          try {
            const container = document.getElementById('heroRawBody');
            if(!container) return;
            const wrapper = document.createElement('div');
            wrapper.className = 'raw-line';
            const ts = new Date().toLocaleTimeString();
            const title = document.createElement('div');
            title.className = 'raw-time';
            title.textContent = `${ts} ${label ? '• ' + label : ''}`;
            const body = document.createElement('div');
            body.className = 'raw-msg';
            try { body.textContent = (typeof payload === 'string') ? payload : JSON.stringify(payload); } catch(e) { body.textContent = String(payload); }
            wrapper.appendChild(title);
            wrapper.appendChild(body);
            container.appendChild(wrapper);
            container.scrollTop = container.scrollHeight;
          } catch(e){}
        };
      })();


      // Build tiles and chooser items
      markets.forEach(m => {
        const codeUpper = (m.code || '').toUpperCase();
        const tile = document.createElement('div');
        tile.className = 'market-tile';
        tile.dataset.code = codeUpper;
        tile.dataset.running = 'false';
        tile.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:8px">
            <div>
              <div class="market-title">${m.label}</div>
              <div class="market-sub">${m.code}</div>
            </div>
            <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
              <div class="market-dot" aria-hidden="true"></div>
              <div style="font-size:11px;color:var(--muted)">status</div>
            </div>
          </div>

          <div class="market-meta">
            <div class="market-stats">
              <div class="market-lastdigit" data-last-digit>—</div>
              <div style="display:flex;flex-direction:column;align-items:flex-start">
                <div class="market-small" data-last-tick>Last tick: —</div>
                <div class="market-small" style="margin-top:4px" data-last-price> </div>
              </div>
            </div>
            <div style="align-self:flex-end">
              <button class="btn" data-expand>Open</button>
            </div>
          </div>
        `;

        // Open overlay on tile click
        tile.addEventListener('click', (ev)=> {
          if (ev.target.closest('[data-expand]')) return;
          openFullDashboard(m);
        });
        tile.querySelector('[data-expand]').addEventListener('click', (ev)=>{
          ev.stopPropagation();
          openFullDashboard(m);
        });

        grid.appendChild(tile);

        // store exact mapping
        tilesByCode.set(codeUpper, tile);

        // chooser item (checkbox)
        const chRow = document.createElement('div');
        chRow.className = 'chooser-item';
        chRow.innerHTML = `<label style="display:flex;align-items:center;gap:8px"><input type="checkbox" data-chooser-code="${m.code}"> <span>${m.label} (${m.code})</span></label>`;
        const cb = chRow.querySelector('input[type="checkbox"]');
        cb.addEventListener('change', ()=> {
          const code = (cb.dataset.chooserCode || '').toUpperCase();
          if(!code) return;
          if(cb.checked) chooserSelected.add(code); else chooserSelected.delete(code);
        });
        chooserList.appendChild(chRow);
      });

      function setTileRunning(code, running){
        const upper = (code || '').toUpperCase();
        const tile = tilesByCode.get(upper);
        if(!tile) return;
        tile.dataset.running = running ? 'true' : 'false';
        const dot = tile.querySelector('.market-dot');
        if(dot) {
          if(running) dot.classList.add('running'); else dot.classList.remove('running');
        }
        if(!running){
          const lastDigitEl = tile.querySelector('[data-last-digit]');
          const lastTickEl = tile.querySelector('[data-last-tick]');
          const priceEl = tile.querySelector('[data-last-price]');
          if(lastDigitEl) lastDigitEl.textContent = '—';
          if(lastTickEl) lastTickEl.textContent = 'Last tick: —';
          if(priceEl) priceEl.textContent = '';
        }
      }
      function setAllTilesRunningForSet(runSet){
        tilesByCode.forEach((tile, code) => {
          setTileRunning(code, runSet.has(code));
        });
      }

      // Controls
      const derivStatus = document.getElementById('derivStatus');
      const btnStartDeriv = document.getElementById('btnStartDeriv');

      let derivRunning = false;

      async function startWorkerOnServer(symbolsArray, scope = 'custom') {
        const body = { scope: scope, symbols: symbolsArray };
        const res = await fetch('/control/start_deriv', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        // if server responds with 202 Accepted => background start: return parsed json if possible, else a success marker
        if(res.status === 202){
          try {
            const j = await res.json().catch(()=>null);
            return { ok: true, starting: true, data: j || null, status: 202 };
          } catch(e){
            return { ok: true, starting: true, status: 202 };
          }
        }

        if (!res.ok) {
          const txt = await res.text().catch(()=>null);
          throw new Error(`start failed: ${res.status} ${txt || ''}`);
        }
        const json = await res.json().catch(()=>null);
        return json || { ok: true };
      }

      async function stopWorkerOnServer() {
        const res = await fetch('/control/stop_deriv', { method: 'POST' });
        if (!res.ok) {
          const txt = await res.text().catch(()=>null);
          throw new Error(`stop failed: ${res.status} ${txt || ''}`);
        }
        return res.json().catch(()=>({ ok: true }));
      }

      btnStartDeriv.addEventListener('click', ()=> {
        if(!derivRunning){
          openDerivChooser();
          return;
        }
        btnStartDeriv.disabled = true;
        stopWorkerOnServer().then((json) => {
          derivRunning = false;
          runningSymbols.clear();
          derivStatus.textContent = 'Deriv: stopped';
          btnStartDeriv.textContent = 'Start Deriv';
          setAllTilesRunningForSet(new Set());
        }).catch((err) => {
          console.error('stop error', err);
          alert('Failed to stop worker: ' + (err && err.message ? err.message : err));
        }).finally(() => {
          btnStartDeriv.disabled = false;
        });
      });

      // ---------- Analysis start/stop behavior (single handler) ----------
      const btnStartAnalysis = document.getElementById('btnStartAnalysis');
      const analysisStatus = document.getElementById('analysisStatus');

      let analysisRunning = false;

      // New behavior:
      // - Click Start Analysis => POST /control/start_analysis, update UI only after success
      // - Click Stop Analysis => POST /control/stop_analysis, update UI only after success
      btnStartAnalysis.addEventListener('click', async ()=> {
        if (btnStartAnalysis._op_in_flight) return;
        btnStartAnalysis._op_in_flight = true;
        try {
          // STOP case
          if (analysisRunning || (btnStartAnalysis.textContent && btnStartAnalysis.textContent.trim().toLowerCase().startsWith('stop'))) {
            try {
              btnStartAnalysis.disabled = true;
              btnStartAnalysis.textContent = 'Stopping…';
              const res = await fetch('/control/stop_analysis', { method: 'POST' });
              if(res.status === 403){
                alert('Stop analysis forbidden (server requires admin access).');
                btnStartAnalysis.textContent = 'Stop Analysis';
                return;
              }
              const j = await res.json().catch(()=>({ok:false}));
              if (res.ok && j.ok) {
                analysisRunning = false;
                analysisStatus.textContent = 'Analysis: stopped';
                btnStartAnalysis.textContent = 'Start Analysis';
              } else {
                const err = (j && (j.error || j.message)) || `status ${res.status}`;
                alert('Stop analysis failed: ' + err);
                btnStartAnalysis.textContent = 'Stop Analysis';
              }
            } catch (e) {
              alert('Stop analysis error: ' + (e && e.message ? e.message : e));
              btnStartAnalysis.textContent = 'Stop Analysis';
            } finally {
              btnStartAnalysis.disabled = false;
            }
            return;
          }

          // START case (directly start; no prompt)
          try {
            btnStartAnalysis.disabled = true;
            btnStartAnalysis.textContent = 'Starting…';
            const res = await fetch('/control/start_analysis', {
              method: 'POST',
              headers: {'Content-Type':'application/json'},
              body: JSON.stringify({})
            });
            const j = await res.json().catch(()=>({ok:false}));
            if (!res.ok || !j.ok) {
              const err = (j && (j.error || j.message)) || `status ${res.status}`;
              alert('Start analysis failed: ' + err);
              btnStartAnalysis.disabled = false;
              btnStartAnalysis.textContent = 'Start Analysis';
              return;
            }
            analysisRunning = true;
            analysisStatus.textContent = 'Analysis: running';
            btnStartAnalysis.textContent = 'Stop Analysis';
            // Do not open overlay automatically — only user opens overlay via icon or Start Analysis (we keep overlay closed)
          } catch(e){
            alert('Error starting analysis: ' + (e && e.message ? e.message : e));
            btnStartAnalysis.textContent = 'Start Analysis';
          } finally {
            try { btnStartAnalysis.disabled = false; } catch(e){}
          }

        } finally {
          btnStartAnalysis._op_in_flight = false;
        }
      });


      // Removed showAnalysisPrompt / hideAnalysisPrompt and analysis prompt handlers per request

      function onAnalysisQuickBtnClick(){
        openAnalysisPanel();
      }

      document.querySelectorAll('input[name="deriv_scope"]').forEach(r=>{
        r.addEventListener('change', ()=>{
          const val = document.querySelector('input[name="deriv_scope"]:checked').value;
          chooserCustomRow.style.display = (val === 'custom') ? 'block' : 'none';
        });
      });
      document.getElementById('chooserCancel').addEventListener('click', closeDerivChooser);

      document.getElementById('chooserStart').addEventListener('click', ()=>{
        const scope = document.querySelector('input[name="deriv_scope"]:checked').value;
        if(scope === 'all'){
          const allSymbols = Array.from(tilesByCode.keys());
          if(allSymbols.length === 0){
            alert('No symbols available to start.');
            return;
          }
          document.getElementById('chooserStart').disabled = true;
          startWorkerOnServer(allSymbols, 'all').then((json) => {
            try { appendGlobalRaw(json, 'start_deriv_resp'); } catch(e){}
            // treat background-start (202) or explicit starting flag as success but UI should reflect 'starting in background'
            if (json && (json.ok || json.starting)) {
              derivRunning = true;
              const allSet = new Set(allSymbols);
              runningSymbols = new Set(allSet);
              derivStatus.textContent = 'Deriv: starting (background)';
              btnStartDeriv.textContent = 'Stop Deriv';
              setAllTilesRunningForSet(allSet);
              closeDerivChooser();
            } else {
              const errMsg = (json && (json.error || JSON.stringify(json))) || 'unknown error';
              alert('Failed to start worker: ' + errMsg);
              try { appendGlobalRaw({ action: 'start_deriv_failed', detail: json }, 'start_deriv'); } catch(e){}
            }
          }).catch((err) => {
            console.error('start all error', err);
            alert('Failed to start worker: ' + (err && err.message ? err.message : err));
          }).finally(() => {
            document.getElementById('chooserStart').disabled = false;
          });

          return;
        }

        if(chooserSelected.size === 0){
          alert('No markets selected. Pick at least one or choose All.');
          return;
        }

        const symbols = Array.from(chooserSelected).map(s => s.toUpperCase());
        document.getElementById('chooserStart').disabled = true;
        startWorkerOnServer(symbols, 'custom').then((json) => {
          try { appendGlobalRaw(json, 'start_deriv_resp'); } catch(e){}
          if (json && (json.ok || json.starting)) {
            derivRunning = true;
            runningSymbols = new Set(symbols);
            derivStatus.textContent = `Deriv: starting (background)`;
            btnStartDeriv.textContent = 'Stop Deriv';
            setAllTilesRunningForSet(runningSymbols);
            closeDerivChooser();
          } else {
            const errMsg = (json && (json.error || JSON.stringify(json))) || 'unknown error';
            alert('Failed to start worker: ' + errMsg);
          }
        }).catch((err) => {
          console.error('start custom error', err);
          alert('Failed to start worker: ' + (err && err.message ? err.message : err));
        }).finally(() => {
          document.getElementById('chooserStart').disabled = false;
        });
      });

      function openDerivChooser(){
        chooser.classList.add('visible');
        chooser.setAttribute('aria-hidden','false');
        document.querySelector('input[name="deriv_scope"][value="all"]').checked = true;
        chooserCustomRow.style.display = 'none';
        chooserSelected.clear();
        chooserList.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
      }
      function closeDerivChooser(){
        chooser.classList.remove('visible');
        chooser.setAttribute('aria-hidden','true');
      }

      // cache most recent analysis payloads so we can replay to overlay when it opens
      window.__hero_last_analysis_payload = null;


      // SSE: attach /events and update tiles only when tile's symbol is running OR overlay is open
      let evt = null;
      function attachSSE(){
        if (typeof EventSource === 'undefined') return;
        try {
          evt = new EventSource('/events');
          evt.addEventListener('open', ()=> console.log('SSE open for market grid'));
          evt.addEventListener('error', (e)=> console.log('SSE error', e));

          // unified handler function for both default message and custom events
          const sseHandler = (ev) => {
            try {
              // ev.data contains the JSON string
              const parsed = JSON.parse(ev.data || '{}');
              // server sometimes wraps payload inside { payload: {...} }
              const payload = (parsed && parsed.payload) ? parsed.payload : parsed;
              // forward to generic handler (this is your existing function)
              handleIncomingPayload(payload);
            } catch (e) {
              console.error('SSE parse/handler error', e);
            }
          };

          // default messages (no "event:" name)
          evt.addEventListener('message', sseHandler);
          // also listen for server's custom analysis events (and tick if server sometimes emits)
          evt.addEventListener('analysis', sseHandler);
          evt.addEventListener('tick', sseHandler);
          // add any other custom event names your server may emit:
          // evt.addEventListener('prediction', sseHandler);
          // evt.addEventListener('prediction_event', sseHandler);

        } catch (e) {
          console.warn('SSE attach failed', e);
        }
      }

      function handleIncomingPayload(payload){
        if(!payload) return;
        const maybeSym = ((payload.symbol || payload.market || '') + '').toString().toUpperCase();
        if(maybeSym === 'ANALYSIS' || payload.analysis_event || payload.analysisEvent || payload.market_scores || payload.scores){
          // cache last analysis payload for overlay replay
          try { window.__hero_last_analysis_payload = payload; } catch(e) {}
          forwardAnalysisPayloadToOverlay(payload);
          const latestAnalysis = document.getElementById('latestAnalysis');
          if(latestAnalysis) latestAnalysis.textContent = payload.analysis_event || payload.analysisEvent || payload.message || 'analysis';
          processAnalysisForRaw(payload);
          return;
        }
        // Otherwise treat as a tick event
        handleTickPayload(payload);
      }

      function forwardAnalysisPayloadToOverlay(payload){
        try {
          const frame = document.getElementById('overlayFrame');
          if(frame && frame.contentWindow){
            frame.contentWindow.postMessage({ type: 'analysis', payload: payload }, '*');
          }
        } catch(e){}
      }

      function payloadMarketCode(payload){
        return (payload.market || payload.symbol || payload.market_code || '').toString().toUpperCase();
      }

      // This replaces the old journal logic. It does NOT create any journal entries.
      // It appends prediction-related events only to the global raw-debug (as requested).
      function processAnalysisForRaw(p){
        try {
          if(!p) return;
          const ae = (p.analysis_event || '').toString().toLowerCase();
          // Detect posted predictions
          if(ae === 'prediction_posted' || p.prediction_posted || (p.prediction_digit !== undefined && (p.prediction_time || p.prediction_id || p.analysis_event))){
            const market = payloadMarketCode(p) || p.market || p.symbol || 'UNKNOWN';
            const predicted = (typeof p.prediction_digit !== 'undefined') ? p.prediction_digit : (p.predicted_digit || p.predicted || null);
            const confidence = (typeof p.confidence !== 'undefined') ? p.confidence : (p.market_score && p.market_score.confidence) ? p.market_score.confidence : null;
            const ob = { event: 'prediction_posted', market, predicted, confidence, raw: p };
            appendGlobalRaw(ob, 'PREDICTION_POSTED');
            return;
          }

          // Detection of result events (prediction_result/outcome)
          if(ae === 'prediction_result' || p.prediction_result || p.result_posted || p.prediction_outcome){
            const market = payloadMarketCode(p) || p.market || p.symbol || 'UNKNOWN';
            const actual = (typeof p.actual_digit !== 'undefined') ? p.actual_digit : (p.result_digit || p.winning_digit || null);
            const explicit = (p.result || p.outcome) ? ((p.result || p.outcome).toString().toLowerCase()) : null;
            const ob = { event: 'prediction_result', market, actual, result: explicit, raw: p };
            appendGlobalRaw(ob, 'PREDICTION_RESULT');
            return;
          }

          // generic analysis_event logging
          if(p.analysis_event || p.message){
            appendGlobalRaw({ event: p.analysis_event || 'analysis', msg: p.message || p.reason || null, raw: p }, 'ANALYSIS_EVENT');
          }
        } catch(e){ console.error('processAnalysisForRaw err', e); appendGlobalRaw('processAnalysisForRaw err: ' + (e && e.message ? e.message : String(e)), 'ERROR'); }
      }

      // SSE tick handling (unchanged)
      function handleTickPayload(payload){
        if(!payload) return;
        const rawSym = (payload.symbol || payload.market || payload.market_code || payload.symbols || '').toString();
        const sym = rawSym.trim().toUpperCase();
        if(!sym) return;

        // throttle DOM updates to at most once per 100ms to prevent rendering thrash
        if (!window.__hero_tick_render_ts) window.__hero_tick_render_ts = 0;
        const now = Date.now();
        const MIN_RENDER_MS = 100; // 10 Hz

        if (now - window.__hero_tick_render_ts < MIN_RENDER_MS) {
          // update in-memory state (optional)
          const rawSym = (payload.symbol || payload.market || payload.market_code || payload.symbols || '').toString().trim().toUpperCase();
          const tile = tilesByCode.get(rawSym);
          if (tile) {
            tile._pendingTick = payload; // will be flushed by scheduled renderer
          }
          if (!window.__hero_tick_flush_scheduled) {
            window.__hero_tick_flush_scheduled = true;
            setTimeout(function(){
              window.__hero_tick_render_ts = Date.now();
              window.__hero_tick_flush_scheduled = false;
              // flush pending updates
              tilesByCode.forEach(function(t, code){
                if (t && t._pendingTick) {
                  var p = t._pendingTick;
                  var last_dec = (p.last_decimal !== undefined) ? p.last_decimal : (p.last || p.d || null);
                  var lastDigitEl = t.querySelector('[data-last-digit]');
                  var lastTickEl = t.querySelector('[data-last-tick]');
                  var priceEl = t.querySelector('[data-last-price]');
                  if(last_dec === null || last_dec === "" || last_dec === undefined){
                    if(lastDigitEl) lastDigitEl.textContent = '—';
                  } else {
                    var d = (typeof last_dec === 'number' || /^\d+$/.test(String(last_dec))) ? String(last_dec) : String(last_dec);
                    if(lastDigitEl) lastDigitEl.textContent = d;
                  }
                  try { if(lastTickEl) lastTickEl.textContent = `Last tick: ${new Date(Number(p.epoch||p.ts||Date.now())*1000).toLocaleTimeString()}`; } catch(e){}
                  if(priceEl){
                    if(p.price !== undefined && p.price !== null) priceEl.textContent = `price: ${p.price}`;
                    else priceEl.textContent = '';
                  }
                  t._pendingTick = null;
                }
              });
            }, MIN_RENDER_MS);
          }
          return;
        }
        window.__hero_tick_render_ts = now;


        const last_dec = (payload.last_decimal !== undefined) ? payload.last_decimal : (payload.last || payload.d || null);
        const epoch = payload.epoch || payload.ts || Math.floor(Date.now()/1000);

        // forward ticks to overlay if overlay open:
        if(overlaySymbol === sym || overlaySymbol === 'ANALYSIS'){
          const frame = document.getElementById('overlayFrame');
          try {
            if(frame && frame.contentWindow){
              frame.contentWindow.postMessage({ type: 'tick', payload: payload }, '*');
            }
          } catch(e){}
        }

        // Only update tile if running
        if(!runningSymbols.has(sym)) return;

        const tile = tilesByCode.get(sym);
        if(!tile) return;

        const lastDigitEl = tile.querySelector('[data-last-digit]');
        const lastTickEl = tile.querySelector('[data-last-tick]');
        const priceEl = tile.querySelector('[data-last-price]');

        if(last_dec === null || last_dec === "" || last_dec === undefined){
          if(lastDigitEl) lastDigitEl.textContent = '—';
        } else {
          const d = (typeof last_dec === 'number' || /^\d+$/.test(String(last_dec))) ? String(last_dec) : String(last_dec);
          if(lastDigitEl) lastDigitEl.textContent = d;
        }

        try {
          if(lastTickEl) lastTickEl.textContent = `Last tick: ${new Date(Number(epoch)*1000).toLocaleTimeString()}`;
        } catch(e){}
        if(priceEl){
          if(payload.price !== undefined && payload.price !== null) priceEl.textContent = `price: ${payload.price}`;
          else priceEl.textContent = '';
        }
      }

      // Overlay iframe logic (isolated)
      const overlay = document.getElementById('dashboardOverlay');
      const overlayFrame = document.getElementById('overlayFrame');
      const titleEl = document.getElementById('overlayHeaderTitle');

      window.addEventListener('message', function(ev){
        try {
          if(!ev.data) return;
          if(ev.data.type === 'close_analysis_overlay'){
            closeOverlay();
            return;
          }
        } catch(e){}
      }, false);

      function openFullDashboard(market){
        overlaySymbol = (market.code || '').toUpperCase();
        titleEl.textContent = market.label + ' — ' + market.code;
        try { overlayFrame.src = 'about:blank'; } catch(e){}
        overlay.classList.add('visible');
        overlay.setAttribute('aria-hidden','false');

        overlayFrame.onload = function(){
          try {
            const doc = overlayFrame.contentDocument || (overlayFrame.contentWindow && overlayFrame.contentWindow.document);
            if(!doc) return;

            // write base shell first
            doc.open();
            doc.write('<!doctype html><html><head>'
              + '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">'
              + '<link rel="stylesheet" href="/static/app.css">'
              + '</head><body></body></html>');
            doc.close();

            // --- replace the fetch block for ANALYSIS with this ---
            if (overlaySymbol === 'ANALYSIS') {
              // load the analysis panel from separate file (server should serve /analysis_panel.html)
              fetch('/analysis_panel.html').then(resp => resp.text()).then(html => {
                try {
                  // Prepend a tiny script that instructs iframe JS not to auto-start analysis.
                  // This runs before any scripts in analysis_panel.html so the panel can check the flag.
                  const injected = '<script>window.HERO_IFRAME_DO_NOT_AUTO_START = true; try{ localStorage.setItem(\"HERO_IFRAME_DO_NOT_AUTO_START\",\"1\"); }catch(e){}<\/script>' + html;
                  doc.open();
                  doc.write(injected);
                  doc.close();

                  const assistantScript = doc.createElement('script');
                  assistantScript.src = '/static/hero_assistant_panel.js?_r=' + Date.now();
                  assistantScript.async = false;
                  assistantScript.onerror = function(){ /* ignore */ };
                  doc.body.appendChild(assistantScript);

                  // notify iframe parent is loaded — still send the message (backwards-compatible)
                  try {
                    overlayFrame.contentWindow.postMessage({ type: 'iframe_parent_loaded', do_not_auto_start: true }, '*');
                    // replay cached analysis payload for overlay that might have missed earlier events
                    try {
                      const cached = window.__hero_last_analysis_payload;
                      if (cached && overlayFrame && overlayFrame.contentWindow) {
                        setTimeout(() => {
                          try {
                            overlayFrame.contentWindow.postMessage({ type: 'analysis', payload: cached }, '*');
                          } catch(e){}
                        }, 80); // short delay to allow iframe listener to attach
                      }
                    } catch(e){} 
                  } catch(e){} 
                } catch (e) {
                  console.error('Error injecting analysis panel html', e);
                }
              }).catch(err => {
                console.error('Failed to load /analysis_panel.html', err);
                try {
                  doc.open();
                  doc.write('<div style="padding:12px;font-family:system-ui;">Failed to load analysis panel. Check /analysis_panel.html on the server.</div>');
                  doc.close();
                } catch(e){}
              });
            } else {
              const tpl = document.getElementById('fullDashboardTemplate');
              const fragment = tpl.content.cloneNode(true);
              doc.body.appendChild(fragment);

              const initScript = document.createElement('script');
              initScript.type = 'text/javascript';
              initScript.text = 'window.HERO_INITIAL_MARKET = ' + JSON.stringify(overlaySymbol) + ';';
              doc.body.appendChild(initScript);

              const bridgeScript = document.createElement('script');
              bridgeScript.type = 'text/javascript';
              bridgeScript.text = `/* parent->iframe bridge (minimal) */
                (function(){
                  try {
                    var INITIAL = (window.HERO_INITIAL_MARKET || '').toString().trim().toUpperCase();
                    var BUF_MAX = 200; var buf = [];
                    function maybe(id){ return document.getElementById(id) || null; }
                    function maybeAppendRaw(s){
                      var rawDebug = maybe('rawDebug'); if(rawDebug){ var el=document.createElement('div'); el.textContent=s; rawDebug.insertBefore(el, rawDebug.firstChild); }
                    }
                    window.addEventListener('message', function(ev){
                      try {
                        if(!ev.data) return;
                        if(ev.data.type === 'tick'){
                          var p = ev.data.payload;
                          var rawSym = (p.symbol || p.market || p.market_code || '').toString().trim().toUpperCase();
                          if(rawSym !== INITIAL) return;
                          buf.push(p);
                          if(buf.length > BUF_MAX) buf.shift();
                          var last10 = maybe('last10Container');
                          if(last10){
                            var arr = (last10._arr || []).slice();
                            arr.push(p.last_decimal === undefined || p.last_decimal === null ? '-' : String(p.last_decimal));
                            if(arr.length > 10) arr = arr.slice(arr.length-10);
                            last10._arr = arr;
                            last10.innerHTML = '';
                            for(var i=0;i<arr.length;i++){
                              var cell=document.createElement('div'); cell.textContent = arr[i];
                              cell.style.cssText='display:inline-flex;width:26px;height:26px;align-items:center;justify-content:center;border-radius:4px;margin:2px;border:1px solid rgba(0,0,0,0.06);font-weight:700';
                              last10.appendChild(cell);
                            }
                          }
                          if(p.analysis_event){
                            maybeAppendRaw('[ANALYSIS] '+(p.analysis_event||'')+' '+(p.message||'')); 
                          }
                        }
                        if(ev.data.type === 'analysis'){
                          var p = ev.data.payload || {};
                          if(p.analysis_event){
                            maybeAppendRaw('[ANALYSIS] '+(p.analysis_event||'')+' '+(p.message||''));
                            var as = maybe('analysisStatusText'); if(as) as.textContent = (p.analysis_event||'')+': '+(p.message||'');
                          }
                        }
                      } catch(e){}
                    }, false);
                  } catch(e){}
                })();`;
              doc.body.appendChild(bridgeScript);

              const appScript = doc.createElement('script');
              appScript.src = '/static/app.js?_r=' + Date.now();
              appScript.async = false;
              appScript.onload = function(){ console.log('app.js loaded inside overlay iframe for', overlaySymbol); };
              appScript.onerror = function(){ /* ignore */ };
              doc.body.appendChild(appScript);

              const assistantScript = doc.createElement('script');
              assistantScript.src = '/static/hero_assistant_panel.js?_r=' + Date.now();
              assistantScript.async = false;
              assistantScript.onerror = function(){ /* ignore */ };
              doc.body.appendChild(assistantScript);
            }
          } catch(err){
            console.error('Error populating overlay iframe:', err);
          } finally {
            overlayFrame.onload = null;
          }
        };

        try {
          const readyDoc = overlayFrame.contentDocument;
          if(readyDoc && readyDoc.readyState === 'complete') overlayFrame.onload();
        } catch(e){}
      }

      function openAnalysisPanel(){
        // open overlay for analysis but do NOT hide the global analysis icon.
        // The icon remains a persistent quick access control.
        openFullDashboard({ code: 'ANALYSIS', label: 'Analysis' });
        // do NOT change analysisIcon.style.display here — keep it visible
      }

      document.getElementById('closeOverlayBtn').addEventListener('click', closeOverlay);
      function closeOverlay(){
        overlay.classList.remove('visible');
        overlay.setAttribute('aria-hidden','true');
        overlaySymbol = null;
        try {
          overlayFrame.src = 'about:blank';
        } catch(e){}
        // always ensure the analysis icon is visible when overlay is closed
        try { analysisIcon.style.display = ''; } catch(e) {}
      }

      analysisIcon.addEventListener('click', function(){
        openAnalysisPanel();
      });

      // start SSE
      attachSSE();
    })();
  </script>

  <script>
  (function () {
    // --- UI elements & helpers ---
    const countEl = document.getElementById('prediction-count');
    const toastContainer = document.getElementById('toast-container');

    function setCount(n) {
      if (!countEl) return;
      countEl.textContent = String(n);
    }

    function incCount(delta = 1) {
      if (!countEl) return;
      const cur = parseInt(countEl.textContent || '0', 10) || 0;
      setCount(cur + delta);
    }

    function showToast(text, type = 'info', ttl = 4000) {
      if (!toastContainer) return;
      try {
        const el = document.createElement('div');
        el.className = 'toast ' + (type || '');
        el.textContent = text;
        // ensure new toasts are visible
        toastContainer.prepend(el);
        requestAnimationFrame(() => el.classList.add('show'));
        setTimeout(() => {
          el.classList.remove('show');
          setTimeout(() => el.remove(), 300);
        }, ttl);
      } catch (e) {
        // non-fatal
        console.warn('showToast failed', e);
      }
    }

    // --- EventSource (create early so no code references an undefined `es`) ---
    let es = null;
    try {
      es = new EventSource('/events');
    } catch (err) {
      console.error('Early EventSource creation failed', err);
      es = null;
    }

    // --- Buffering & flush logic (aggregates events then calls update handler) ---
    let eventBuffer = [];
    let flushing = false;

    // Small local fallback for updateUIForEvent:
    // If your app defines window.updateUIForEvent, prefer that; otherwise this is a no-op.
    function updateUIForEvent(evt) {
      try {
        if (typeof window.updateUIForEvent === 'function') {
          window.updateUIForEvent(evt);
        } else {
          // no-op if page doesn't supply an update function
        }
      } catch (e) {
        console.error('updateUIForEvent error', e);
      }
    }

    function scheduleFlush() {
      if (flushing) return;
      flushing = true;
      requestAnimationFrame(() => {
        try {
          const buffer = eventBuffer.splice(0, eventBuffer.length);
          // aggregate latest-by-key to avoid repeated DOM churn
          const latestByKey = {};
          for (const ev of buffer) {
            // canonical key: analysis per market prefer per-symbol dedupe
            const key =
              ev &&
              ev.payload &&
              (ev.event === 'analysis' || (ev.payload && ev.payload.analysis_event))
                ? `analysis:${((ev.payload && (ev.payload.market || ev.payload.symbol)) || '').toString().toUpperCase()}`
                : ev.event || JSON.stringify(ev).slice(0, 60);
            latestByKey[key] = ev;
          }
          Object.values(latestByKey).forEach(updateUIForEvent);
        } catch (err) {
          console.error('scheduleFlush error', err);
        } finally {
          flushing = false;
        }
      });
    }

    // --- Helper that safely pushes parsed SSE messages into the buffer ---
    function pushParsedSSE(parsed) {
      try {
        // Keep small guard: only push objects
        if (!parsed) return;
        eventBuffer.push(parsed);
        scheduleFlush();
      } catch (e) {
        // ignore
      }
    }

    // --- Attach handlers to a given EventSource instance (idempotent) ---
    function attachSSEHandlers(source) {
      if (!source || typeof source.addEventListener !== 'function') return;

      // generic message handler: default server data lines
      try {
        source.addEventListener('message', function (e) {
          try {
            const parsed = JSON.parse(e.data || '{}');
            pushParsedSSE(parsed);
          } catch (err) {
            // ignore malformed lines
          }
        });
      } catch (e) {
        // ignore if already attached or unsupported
      }

      // analysis-named events — keep parity with previous behaviour
      try {
        source.addEventListener('analysis', function (ev) {
          try {
            const parsed = JSON.parse(ev.data || '{}');
            const payload = parsed.payload || parsed;
            const evname = (payload.analysis_event || payload.event || '').toString();

            // small specialized UI actions:
            if (evname === 'prediction_toast') {
              const msg = payload.message || (payload.symbol ? `${payload.symbol} → ${payload.digit ?? payload.prediction_digit}` : 'Prediction');
              showToast(msg, 'success', 4500);
            } else if (evname === 'prediction_posted') {
              console.log('[prediction_posted]', payload);
            } else if (evname === 'prediction_stats') {
              const c = parseInt(payload.produced_count || 0, 10) || 0;
              setCount(c);
            }

            // still let the generic buffer+flush handle UI updates too
            pushParsedSSE({ event: 'analysis', payload: payload });
          } catch (e) {
            console.error('analysis event parse error', e, ev && ev.data);
          }
        });
      } catch (e) {}

      // fallback onmessage to support servers that don't use named events
      try {
        if (!source.onmessage) {
          source.onmessage = function (ev) {
            try {
              const parsed = JSON.parse(ev.data || '{}');
              const payload = parsed.payload || parsed;
              if (payload && payload.analysis_event) {
                const evname = payload.analysis_event;
                if (evname === 'prediction_toast') {
                  showToast(payload.message || `${payload.symbol} → ${payload.digit}`, 'success', 4500);
                } else if (evname === 'prediction_stats') {
                  setCount(parseInt(payload.produced_count || 0, 10) || 0);
                }
              }
              pushParsedSSE(parsed);
            } catch (e) {
              // ignore
            }
          };
        }
      } catch (e) {}

      // error handler
      try {
        source.onerror = function (err) {
          // browser will auto-reconnect; surface helpful message
          console.warn('SSE error', err);
        };
      } catch (e) {}
    }

    // Attach to initial es if created
    if (es) {
      attachSSEHandlers(es);
    } else {
      // Try one more time to create + attach (graceful fallback)
      try {
        es = new EventSource('/events');
        attachSSEHandlers(es);
      } catch (e) {
        console.error('Failed to open EventSource at fallback attempt', e);
        // At this point SSE is unavailable; UI still works but won't receive real-time events.
      }
    }

    // Expose a small debug hook for manual pushes (optional)
    window.__hero_sse_push_for_debug = function (obj) {
      try {
        pushParsedSSE(obj);
      } catch (e) {}
    };
  })();
  </script>

  <script>
  /* DEBUG helper: lightweight tick-journal that logs into the parent global raw debug.
     Non-destructive and separate from analysis logic.
  */
  (function(){
    const ENABLE_TICK_LOG = false;
    if(!ENABLE_TICK_LOG) return;
    try {
      if (typeof EventSource === 'undefined') return;
      const es = new EventSource('/events');
      es.addEventListener('open', ()=> console.log('[tick-log] SSE open'));
      es.addEventListener('error', (e)=> console.warn('[tick-log] SSE error', e));
      es.onmessage = function(ev){
        try {
          const parsed = JSON.parse(ev.data || '{}');
          const payload = (parsed && parsed.payload) ? parsed.payload : parsed;
          if(payload && (payload.last_decimal !== undefined || payload.last !== undefined || payload.d !== undefined)){
            // append to global raw debug
            try { parent.appendGlobalRaw ? parent.appendGlobalRaw({ tick: payload }, 'TICK') : null; } catch(e){}
          }
        } catch(e){}
      };
    } catch(e){}
  })();
  </script>

  {% include "_journal.html" %}

  <script>
  (function(){
    // Find any existing authenticate control by text or data attribute and normalize it
    function findAuthControls(){
      const candidates = Array.from(document.querySelectorAll('button, a, input[type="button"], input[type="submit"]'));
      const authEls = [];
      const authRegex = /\b(auth|authenticate|authenticat(e|ion)|login|sign ?in)\b/i;
      candidates.forEach(el => {
        try {
          const txt = (el.textContent || el.innerText || el.value || '').trim();
          const da = (el.getAttribute && (el.getAttribute('data-auth') || el.dataset.auth)) || null;
          if (da || authRegex.test(txt)) authEls.push(el);
        } catch(e){}
      });
      return authEls;
    }

    // Try to open modal using likely global functions exposed by auth_modal.js
    async function tryOpenAuthModal(){
      const tryNames = ['openAuthModal','showAuthModal','openAuth','showAuth','authModalShow'];
      for(const n of tryNames){
        if(typeof window[n] === 'function'){
          try { window[n](); return true; } catch(e) { /* continue */ }
        }
      }
      // If no global function available, attempt to reveal an existing modal node
      const modalCandidates = ['#authModal','#auth-modal','#authModalOverlay','.auth-modal'];
      for(const sel of modalCandidates){
        const el = document.querySelector(sel);
        if(el){
          try { el.style.display = 'block'; el.setAttribute && el.setAttribute('aria-hidden','false'); return true; } catch(e){}
        }
      }

      // Fallback: attempt to fetch static auth.html into a temporary modal
      try {
        const url = '/static/auth.html';
        const resp = await fetch(url, { credentials: 'same-origin' });
        if(resp.ok){
          const html = await resp.text();
          createFallbackAuthModal(html);
          return true;
        }
      } catch(e){}
      return false;
    }

    function createFallbackAuthModal(html){
      try {
        if(document.getElementById('heroAuthFallback')) return;
        const overlay = document.createElement('div');
        overlay.id = 'heroAuthFallback';
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.style.background = 'rgba(0,0,0,0.45)';
        overlay.style.zIndex = 100000;
        overlay.innerHTML = '<div style="max-width:780px;width:94%;max-height:88vh;overflow:auto;background:#fff;border-radius:10px;padding:12px;box-shadow:0 30px 80px rgba(2,6,23,0.35)">' +
                            '<div style="display:flex;justify-content:flex-end"><button id="heroAuthFallbackClose" style="border:0;background:transparent;font-size:20px;cursor:pointer">✕</button></div>' +
                            '<div id="heroAuthFallbackInner"></div></div>';
        document.body.appendChild(overlay);
        document.getElementById('heroAuthFallbackInner').innerHTML = html;
        document.getElementById('heroAuthFallbackClose').addEventListener('click', function(){ overlay.remove(); });
      } catch(e){ console.error('createFallbackAuthModal err', e); }
    }

    // Intercept click on auth controls and route to modal instead of navigation (prevent 404)
    function attachAuthInterceptors(){
      const authEls = findAuthControls();
      authEls.forEach(el => {
        // normalize: give element a class/id so we can style and find it later
        try {
          el.classList.add('auth-button');
          if(!el.id) el.id = 'btnAuthenticate';
        } catch(e){}

        // override click/navigation
        const onClick = async function(evt){
          try {
            evt.preventDefault();
            evt.stopPropagation();
          } catch(e){}
          // open our modal (tries multiple strategies)
          const ok = await tryOpenAuthModal();
          if(!ok){
            // fallback UX: inform user
            alert('Authentication UI not found on the server. Contact admin or check /static/auth.html');
          }
        };

        // remove native navigation if it's an <a>
        if(el.tagName && el.tagName.toLowerCase() === 'a'){
          el.addEventListener('click', onClick, { passive: false });
        } else {
          el.addEventListener('click', onClick);
        }
      });
    }

    // Wrap existing onAuthSuccess so we can update UI when auth returns
    (function wrapOnAuthSuccess(){
      const original = window.onAuthSuccess;
      window.onAuthSuccess = function(authData){
        try {
          // mark auth button(s) as authenticated & clickable behavior
          const els = findAuthControls();
          els.forEach(e => {
            try {
              e.classList.add('authenticated');
              e.classList.remove('disabled');
              e.removeAttribute && e.removeAttribute('disabled');
              e.title = 'Authenticated — click to view account';
              // make clicking show balances (if available) or open modal
              e.onclick = function(ev){
                ev && ev.preventDefault && ev.preventDefault();
                // try a small menu: show saved balance or call existing hook
                try {
                  if(typeof window.openAuthAccount === 'function'){ window.openAuthAccount(); return; }
                  const demoRaw = localStorage.getItem('hero_balance_demo');
                  const realRaw = localStorage.getItem('hero_balance_real');
                  const parts = [];
                  if(demoRaw) parts.push('Demo: ' + demoRaw);
                  if(realRaw) parts.push('Real: ' + realRaw);
                  if(parts.length) alert('Balances:\n' + parts.join('\n'));
                  else alert('Authenticated. No local balances saved.'); 
                } catch(e){ alert('Authenticated.'); }
              };
            } catch(e){}
          });
        } catch(e){}
        try { if(typeof original === 'function') original(authData); } catch(e){}
      };
    })();

    // initial run
    setTimeout(function(){
      attachAuthInterceptors();
    }, 300);

    // also re-run if DOM changes (auth_modal might inject)
    const obs = new MutationObserver(function(){ attachAuthInterceptors(); });
    obs.observe(document.body || document.documentElement, { childList: true, subtree: true });

  })();
  </script>

  <script>
  (function () {
    // New token-check + non-blocking notification helpers.
    // Replaces old /control/get_token usage with /control/get_tokens.

    async function checkToken() {
      try {
        const resp = await fetch('/control/get_tokens').catch(()=>null);
        const j = resp ? await resp.json().catch(()=>({ok:false})) : null;
        const localDemo = !!localStorage.getItem('hero_token_demo');
        const localReal = !!localStorage.getItem('hero_token_real');

        // If server unreachable but tokens exist locally, don't show No Tokens notification.
        if ((!j || !j.ok) && (localDemo || localReal)) {
          try {
            const demoEl = document.getElementById('hero-demo-status-small') || document.getElementById('demo-status');
            const realEl = document.getElementById('hero-real-status-small') || document.getElementById('real-status');
            if(demoEl) demoEl.textContent = localDemo ? 'Token (local)' : 'No token';
            if(realEl) realEl.textContent = localReal ? 'Token (local)' : 'No token';
          } catch(e){}
          try { if(window.__idx_start_balance_polling) window.__idx_start_balance_polling(); } catch(e){}
          return;
        }

        if (!j || !j.ok) {
          _showNoTokensNotification();
          return;
        }

        const demo_present = !!j.demo_present;
        const real_present = !!j.real_present;
        const demo_mask = j.demo_mask || '';
        const real_mask = j.real_mask || '';

        if (demo_present || real_present) {
          _showTokensFoundNotification({ demo_present, real_present, demo_mask, real_mask });
        } else {
          _showNoTokensNotification();
        }
      } catch (e) {
        console.error('checkToken err', e);
        const localDemo = !!localStorage.getItem('hero_token_demo');
        const localReal = !!localStorage.getItem('hero_token_real');
        if(localDemo || localReal){
          try { if(window.__idx_start_balance_polling) window.__idx_start_balance_polling(); } catch(e){}
          return;
        }
        _showNoTokensNotification();
      }
    }

    function _showTokensFoundNotification({ demo_present, real_present, demo_mask, real_mask }) {
      try {
        const existing = document.getElementById('heroTokenNotification');
        if (existing) existing.remove();

        const container = document.createElement('div');
        container.id = 'heroTokenNotification';
        container.style.position = 'fixed';
        container.style.right = '18px';
        container.style.top = '18px';
        container.style.zIndex = 12000;
        container.style.background = '#fff';
        container.style.border = '1px solid rgba(0,0,0,0.06)';
        container.style.padding = '10px';
        container.style.borderRadius = '10px';
        container.style.boxShadow = '0 12px 36px rgba(2,6,23,0.12)';
        container.style.fontSize = '13px';
        container.style.maxWidth = '360px';

        const title = document.createElement('div');
        title.style.fontWeight = 700;
        title.style.marginBottom = '6px';
        title.textContent = 'Tokens found';

        const body = document.createElement('div');
        body.style.marginBottom = '10px';
        body.style.color = '#374151';
        body.innerHTML = `Demo: <strong>${demo_present ? demo_mask : '—'}</strong> &nbsp;•&nbsp; Real: <strong>${real_present ? real_mask : '—'}</strong>`;

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '8px';
        actions.style.justifyContent = 'flex-end';

        const manageBtn = document.createElement('button');
        manageBtn.className = 'btn';
        manageBtn.textContent = 'Manage tokens';
        manageBtn.addEventListener('click', function () {
          tryOpenAuthModal().catch(()=>{ alert('Open authentication UI'); });
        });

        const dismissBtn = document.createElement('button');
        dismissBtn.className = 'btn';
        dismissBtn.textContent = 'Dismiss';
        dismissBtn.addEventListener('click', function () {
          try { container.remove(); } catch(e){}
        });

        actions.appendChild(manageBtn);
        actions.appendChild(dismissBtn);

        container.appendChild(title);
        container.appendChild(body);
        container.appendChild(actions);

        document.body.appendChild(container);

        let timer = setTimeout(()=> { try { container.remove(); } catch(e){} }, 10000);
        container.addEventListener('mouseenter', ()=> clearTimeout(timer));
        container.addEventListener('mouseleave', ()=> { timer = setTimeout(()=> { try { container.remove(); } catch(e){} }, 6000); });
      } catch (e) {
        console.error('_showTokensFoundNotification err', e);
      }
    }

    function _showNoTokensNotification() {
      try {
        const localDemo = !!localStorage.getItem('hero_token_demo');
        const localReal = !!localStorage.getItem('hero_token_real');
        if(localDemo || localReal) return;

        const existing = document.getElementById('heroTokenNotification');
        if (existing) existing.remove();

        const container = document.createElement('div');
        container.id = 'heroTokenNotification';
        container.style.position = 'fixed';
        container.style.right = '18px';
        container.style.top = '18px';
        container.style.zIndex = 12000;
        container.style.background = '#fff';
        container.style.border = '1px solid rgba(0,0,0,0.06)';
        container.style.padding = '10px';
        container.style.borderRadius = '10px';
        container.style.boxShadow = '0 12px 36px rgba(2,6,23,0.12)';
        container.style.fontSize = '13px';
        container.style.maxWidth = '360px';

        const title = document.createElement('div');
        title.style.fontWeight = 700;
        title.style.marginBottom = '6px';
        title.textContent = 'No tokens found';

        const body = document.createElement('div');
        body.style.marginBottom = '10px';
        body.style.color = '#374151';
        body.textContent = 'No DERIV tokens detected. Please authenticate your accounts to enable trading.';

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '8px';
        actions.style.justifyContent = 'flex-end';

        const authDemo = document.createElement('button');
        authDemo.className = 'btn';
        authDemo.textContent = 'Authenticate demo';
        authDemo.addEventListener('click', function () {
          tryOpenAuthModal().catch(()=>{ alert('Open authentication UI for demo'); });
        });

        const authReal = document.createElement('button');
        authReal.className = 'btn';
        authReal.textContent = 'Authenticate real';
        authReal.addEventListener('click', function () {
          tryOpenAuthModal().catch(()=>{ alert('Open authentication UI for real'); });
        });

        const dismissBtn = document.createElement('button');
        dismissBtn.className = 'btn';
        dismissBtn.textContent = 'Dismiss';
        dismissBtn.addEventListener('click', function () {
          try { container.remove(); } catch(e){}
        });

        actions.appendChild(authDemo);
        actions.appendChild(authReal);
        actions.appendChild(dismissBtn);

        container.appendChild(title);
        container.appendChild(body);
        container.appendChild(actions);

        document.body.appendChild(container);
      } catch (e) {
        console.error('_showNoTokensNotification err', e);
      }
    }

    async function tryOpenAuthModal() {
      if (typeof window.tryOpenAuthModal === 'function') {
        return window.tryOpenAuthModal();
      }
      const tryNames = ['openAuthModal','showAuthModal','openAuth','showAuth','authModalShow'];
      for(const n of tryNames){
        if(typeof window[n] === 'function'){
          try { window[n](); return; } catch(e) { /* continue */ }
        }
      }
      if (typeof window.createFallbackAuthModal === 'function') {
        const resp = await fetch('/static/auth.html', { credentials: 'same-origin' });
        if (resp.ok) {
          const html = await resp.text();
          window.createFallbackAuthModal && window.createFallbackAuthModal(html);
          return;
        }
      }

      window.location.href = '/static/auth.html?return=' + encodeURIComponent(window.location.pathname + window.location.search);
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', checkToken);
    } else {
      checkToken();
    }
  })();
  </script>
  <script src="/static/hero_assistant_panel.js"></script>
  <script src="/static/autotrade_panel.js"></script>
  <script src="/static/auth_modal.js"></script>
</body>
</html>
