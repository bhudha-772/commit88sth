v<!-- templates/_journal.html - updated to accept final results and message-event SSE shapes -->
<style>
/* Journal modal & layout */
#journal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.28); z-index: 1000; }
#journal-modal { display: none; position: fixed; right: 18px; top: 72px; width: 920px; max-width: calc(100% - 40px); max-height: calc(100% - 140px); background: #fff; color: #000; border-radius: 10px; box-shadow: 0 30px 80px rgba(0,0,0,0.18); padding: 12px; overflow: hidden; transform-origin: 95% 0%; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; z-index: 1100; }
#journal-header-band { display:flex; align-items:center; justify-content:space-between; background: #000; padding:10px; border-radius:8px; color:#fff; }
#journal-header-left { display:flex; gap:12px; align-items:center; }
#journal-header-left h3 { margin:0; font-size:16px; font-weight:700; color:#fff; }
#journal-close { background:transparent; border:0; font-size:18px; cursor:pointer; color:#fff; }


/* Main panel scrolls vertically only */
#journal-main {
  flex:1;
  overflow-y: auto;
  overflow-x: hidden;      /* hide any horizontal overflow inside the main column */
  max-height: calc(100% - 160px);
  background: #fff;
  border-radius: 6px;
  padding: 6px;
}

#journal-container {
  max-height: 380px; /* adjust to your UI */
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 8px;
  background: #fff;
}

/* Optional: visible thin scrollbar for modern browsers */
#journal-container::-webkit-scrollbar { width: 10px; }
#journal-container::-webkit-scrollbar-thumb { border-radius: 6px; background: rgba(218, 105, 105, 0.15); }

/* ---------- SCROLL-FIX FOR FLEX LAYOUT ---------- */
/* Ensure the body-wrap has a constrained height relative to the modal */
#journal-body-wrap {
  display: flex;
  gap: 12px;
  /* reserve space for header band (approx 64px), the rest becomes scrollable */
  height: calc(100% - 64px);      /* <- ensures inner children have a height to work with */
  max-height: calc(100% - 64px);
  margin-top: 10px;
  padding-right: 6px;
  overflow: hidden;               /* outer wrapper should not scroll itself */
}

/* Main panel MUST be allowed to shrink inside flex and handle its own scrolling */
#journal-main {
  flex: 1 1 auto;        /* flexible but allowed to shrink/grow */
  min-height: 0;         /* CRITICAL: allows the element to shrink so overflow works */
  overflow-y: auto;      /* vertical scroll appears here */
  overflow-x: hidden;    /* hide any horizontal overflow inside the main column */
  max-height: 100%;
  background: #fff;
  border-radius: 6px;
  padding: 6px;
  box-sizing: border-box;
}

/* debug panel: also allow shrink + own scrolling */
#journal-debug {
  width: 360px;
  max-width: 40%;
  border-left: 1px solid #eee;
  padding-left: 12px;
  min-height: 0;         /* ALLOW shrink in flex container */
  overflow: auto;        /* its own scrollbar when content overflows */
}

/* ensure table layout doesn't force modal larger than parent */
#journal-table {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;   /* allow cells to wrap and prevent horizontal expansion */
  word-break: break-word;
}


/* Header - sticky so it stays visible while scrolling */
#journal-table thead th {
  position: sticky;
  top: 0;
  z-index: 2;
  text-align:left;
  padding:10px 12px;
  background:#000;
  color:#fff;
  border-bottom:1px solid #111;
  font-weight:600;
  font-size:13px;
}

/* Body rows normal flow (allow wrapping inside cells) */
#journal-table tbody tr { display: table-row; width: 100%; box-sizing: border-box; }
#journal-table tbody td {
  padding:9px 12px;
  border-top:1px solid #f2f2f2;
  vertical-align:middle;
  color:#111;
  word-break:break-word;
  white-space: normal;     /* allow wrapping */
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Prevent very-long id strings from blowing out the layout */
#journal-table tbody td:nth-child(9) {
  max-width: 260px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}


.result-badge { display:inline-block; padding:4px 8px; border-radius:999px; font-weight:700; font-size:12px; color:#fff; }
.result-win { background: #16a34a; } .result-loss { background: #dc2626; } .result-posted { background: #f59e0b; } .result-draw, .result-unknown { background: #6b7280; }
.row-win td { background: rgba(22,163,74,0.04); } .row-loss td { background: rgba(220,38,38,0.04); } .row-posted td { background: rgba(245,158,11,0.03); }

.profit-positive { color: #166534; font-weight:700; } .profit-negative { color: #991b1b; font-weight:700; } .profit-zero { color: #374151; }

#journal-controls { display:flex; gap:8px; align-items:center; }
#journal-load-history, #journal-clear-all, #journal-debug-toggle { background:#fff; color:#111; border:1px solid #111; padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
#journal-status { color:#333; font-size:13px; margin-left:8px; }

.debug-box { font-family: ui-monospace, "Courier New", monospace; font-size:12px; color:#111; background:#fafafa; border:1px solid #eee; padding:8px; border-radius:8px; max-height:340px; overflow:auto; white-space:pre-wrap; word-break:break-word; }
.debug-item { margin-bottom:8px; padding:6px; border-radius:6px; background:#fff; border:1px solid #eee; }
.debug-missing { color:#b91c1c; font-weight:700; }
.debug-ok { color:#065f46; font-weight:700; }

@media (max-width:1200px) {
  #journal-modal { width: 94%; right: 50%; transform: translateX(50%); top: 80px; }
  #journal-debug { display:none; }
}
</style>

<div id="journal-overlay" aria-hidden="true"></div>

<div id="journal-modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div id="journal-header-band">
    <div id="journal-header-left">
      <h3>Prediction Journal</h3>
    </div>

    <div style="display:flex;align-items:center;gap:10px;">
      <div id="journal-controls">
        <button id="journal-load-history" title="Load server history">Load history</button>
        <button id="journal-clear-all" title="Clear all displayed predictions">Clear All</button>
        <button id="journal-debug-toggle" title="Toggle debug panel">Toggle Debug</button>
        <small id="journal-status"></small>
      </div>
      <button id="journal-close" aria-label="Close">✕</button>
    </div>
  </div>

  <div id="journal-body-wrap">
    <div id="journal-main" tabindex="0" aria-label="Journal main">
      <table id="journal-table" aria-describedby="journal-status">
        <thead>
          <tr>
            <th style="width:12%">ts</th>
            <th style="width:14%">market</th>
            <th style="width:7%">pred</th>
            <th style="width:7%">actual</th>
            <th style="width:9%">result</th>
            <th style="width:8%">profit</th>
            <th style="width:8%">pct</th>
            <th style="width:7%">conf</th>
            <th style="width:28%">id</th>
          </tr>
        </thead>
        <tbody id="journal-body">
          <tr><td colspan="9" style="padding:18px;color:#666">Open the journal to load last settled predictions...</td></tr>
        </tbody>
      </table>
    </div>

    <div id="journal-debug" aria-hidden="true" style="display:none;">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
        <strong>Debug panel</strong>
        <small style="color:#666"> (last raw SSE events & extraction results)</small>
      </div>
      <div id="debug-summary" class="debug-box" style="margin-bottom:8px;">No events yet.</div>
      <div style="margin-bottom:6px;"><button id="debug-clear" class="debug-clear" style="padding:6px 8px">Clear debug</button></div>
      <div id="debug-list" class="debug-box"></div>
      <div style="margin-top:8px;font-size:12px;color:#666">Tip: open DevTools → Console to see parsed logs.</div>
    </div>
  </div>
</div>

<div id="toast-wrap" aria-live="polite" aria-atomic="true"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // CONFIG: set SHOW_POSTED=false to record only final results (recommended).
  // Set to true only for debugging if you want the amber POSTED rows.
  const SHOW_POSTED = false;
  const VERBOSE_SSE_CONSOLE = false;

  const ROLLING_COUNT = 10;
  const SESSION_CAP = 300;
  const journalBody = document.getElementById('journal-body');
  const loadHistoryBtn = document.getElementById('journal-load-history');
  const clearBtn = document.getElementById('journal-clear-all');
  const debugToggle = document.getElementById('journal-debug-toggle');
  const debugPanel = document.getElementById('journal-debug');
  const debugSummary = document.getElementById('debug-summary');
  const debugList = document.getElementById('debug-list');
  const debugClearBtn = document.getElementById('debug-clear');
  const statusEl = document.getElementById('journal-status');
  const overlay = document.getElementById('journal-overlay');
  const modal = document.getElementById('journal-modal');
  const closeBtn = document.getElementById('journal-close');

  let entries = []; // newest-first
  let sse = null;
  let modalOpen = false;
  const JOURNAL_ENDPOINT = '/control/journal';

  // DEBUG storage
  const MAX_DEBUG = 60;
  let lastRawEvents = []; // newest-first

  function addDebugEvent(payload, extracted, note) {
    try {
      const ts = Math.floor(Date.now()/1000);
      const item = { ts, payload, extracted, note };
      lastRawEvents.unshift(item);
      if (lastRawEvents.length > MAX_DEBUG) lastRawEvents.length = MAX_DEBUG;
      renderDebug();
    } catch (e) { console.error('debug add err', e); }
  }
  function renderDebug() {
    if (!lastRawEvents.length) {
      debugSummary.textContent = 'No events yet.';
      debugList.innerHTML = '';
      return;
    }
    debugSummary.textContent = `Received ${lastRawEvents.length} recent SSE events (newest first).`;
    debugList.innerHTML = lastRawEvents.map(ev => {
      const t = new Date(ev.ts*1000).toISOString().replace('T',' ').split('.')[0];
      const ex = ev.extracted || {};
      const pid = ex.prediction_id || ex.pred_id || ex.id || '—';
      const pd = (ex.predicted_digit ?? ex.prediction_digit ?? ex.digit ?? '—');
      const prof = (ex.profit != null ? ex.profit : (ex.profit_amount != null ? ex.profit_amount : '—'));
      const res = (ex.result || '—');
      const note = ev.note ? `<div style="color:#666;font-size:12px">note: ${ev.note}</div>` : '';
      const miss = [];
      if ((ex.predicted_digit === null || ex.predicted_digit === undefined) && (ex.digit === null || ex.digit === undefined)) miss.push('prediction_digit/digit');
      const missHtml = miss.length ? `<div class="debug-missing">Missing: ${miss.join(', ')}</div>` : `<div class="debug-ok">OK fields present</div>`;
      const pretty = JSON.stringify(ev.payload, null, 2).replace(/</g,'&lt;').replace(/>/g,'&gt;').slice(0,2000);
      return `<div class="debug-item"><div style="font-size:12px;color:#666">${t} — id:${pid} pred:${pd} profit:${prof} res:${res}</div>${note}${missHtml}<pre style="margin-top:6px;font-size:11px;max-height:220px;overflow:auto;background:#fff;padding:6px;border-radius:6px;border:1px solid #f0f0f0">${pretty}</pre></div>`;
    }).join('');
  }
  debugClearBtn && debugClearBtn.addEventListener('click', () => { lastRawEvents = []; renderDebug(); });

  // Short, user-friendly ISO (local) timestamp
  function isoShort(ts) {
    try {
      if (!ts) return '';
      // detect ms or seconds; normalize to milliseconds
      let ms = null;
      if (typeof ts === 'number') {
        if (ts > 1000000000000) ms = ts;           // already ms
        else if (ts > 1000000000) ms = ts * 1000;  // seconds -> ms
        else ms = Date.now();
      } else if (typeof ts === 'string' && ts.match(/^\d+$/)) {
        const n = Number(ts);
        if (n > 1000000000000) ms = n;
        else if (n > 1000000000) ms = n * 1000;
      } else {
        const d = new Date(ts);
        if (!isNaN(d.getTime())) ms = d.getTime();
      }
      if (!ms) return String(ts || '');
      const d = new Date(ms);
      // Produce concise string: "YYYY-MM-DD HH:MM:SS"
      const y = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mi = String(d.getMinutes()).padStart(2,'0');
      const ss = String(d.getSeconds()).padStart(2,'0');
      return `${y}-${mm}-${dd} ${hh}:${mi}:${ss}`;
    } catch (e) { return String(ts); }
  }

  // heuristics to render nicer market names
  function prettyMarket(sym) {
    if (!sym) return '';
    try {
      const s = String(sym).trim();
      // Volatility codes: R_10, R10, R_25 -> Volatility 10
      const m1 = s.match(/^R[_]?(\d+)$/i);
      if (m1) return `Volatility ${m1[1]}`;

      // Known pattern: contains 'BULL' => make friendly "RD Bull" or "RDBULL" -> "RD Bull"
      if (/BULL/i.test(s)) {
        const out = s.replace(/_/g, ' ').replace(/BULL/i, 'Bull');
        return out.replace(/\b([A-Z]{2,})\b/g, w => w.charAt(0) + w.slice(1).toLowerCase());
      }

      // Pattern like 1HZ50V or 1HZ100V: split letters and digits
      const parts = s.match(/^([A-Za-z]*)(\d+)([A-Za-z0-9]*)$/i);
      if (parts) {
        const a = parts[1] ? parts[1].replace(/_/g,'') : '';
        const b = parts[2] ? parts[2] : '';
        const c = parts[3] ? parts[3].replace(/_/g,'') : '';
        let out = '';
        if (a) out += a.toUpperCase();
        if (b) out += (out ? ' ' : '') + b;
        if (c) out += ' ' + c.toUpperCase();
        return out;
      }

      // Fallback: replace underscores, title-case long acronyms
      return s.replace(/_/g, ' ').replace(/\b([A-Z]{2,})\b/g, w => w.charAt(0) + w.slice(1).toLowerCase());
    } catch (e) { return sym; }
  }

  // normalize / extract function - tolerant to nested payloads
  function normalizeItem(e) {
    if (!e) return null;
    let core = {};
    // Accept either e.entry (legacy) or e or e.payload (SSE nested)
    if (e.entry && typeof e.entry === 'object') core = Object.assign({}, e.entry);
    else if (e.payload && typeof e.payload === 'object') core = Object.assign({}, e.payload);
    else core = Object.assign({}, e);

    core.raw = core.raw || e.raw || e;

    // Try many name variants for predicted digit
    core.predicted_digit = core.predicted_digit ?? core.prediction_digit ?? core.predicted ?? core.pred ?? core.digit ?? null;

    // Observed/actual ticks: accept tick_stream (array of objects) or observed (array)
    core.observed_ticks = core.observed_ticks ?? core.observed ?? core.actuals ?? core.tick_stream ?? [];
    if (!Array.isArray(core.observed_ticks)) core.observed_ticks = [];

    core.prediction_id = core.prediction_id ?? core.pred_id ?? core.id ?? core.prediction ?? '';
    core.confidence = core.confidence ?? core.conf ?? core.confidence_score ?? null;
    core.timestamp = core.timestamp ?? core.ts ?? core.epoch ?? core.timestamp_ms ?? null;
    core.symbol = core.symbol ?? core.market ?? core.market_code ?? core.symbolic ?? '';
    core.epoch = core.epoch ?? core.epoch_ts ?? null;
    core.result = core.result ?? core.outcome ?? core.status ?? null;

    // PROFIT extraction
    let p = null, pp = null;
    try {
      p = core.profit ?? core.profit_amount ?? core.contract_profit ?? null;
      if (p == null && core.raw) {
        p = core.raw.profit ?? (core.raw.final_contract && core.raw.final_contract.profit) ?? (core.raw.final && core.raw.final.profit) ?? null;
      }
      if (p == null && core.final_contract && typeof core.final_contract === 'object') p = core.final_contract.profit ?? null;
    } catch (err) { p = null; }
    try {
      pp = core.profit_percent ?? core.profit_percentage ?? core.profitPct ?? null;
      if (pp == null && core.raw) pp = core.raw.profit_percentage ?? core.raw.profitPercent ?? (core.raw.final_contract && core.raw.final_contract.profit_percentage) ?? null;
      if (pp == null && core.final_contract && typeof core.final_contract === 'object') pp = core.final_contract.profit_percentage ?? null;
    } catch (err) { pp = null; }

    core.profit = (typeof p === 'string' && p !== '') ? (isNaN(Number(p)) ? null : Number(p)) : (typeof p === 'number' ? p : (p == null ? null : Number(p)));
    core.profit_percent = (typeof pp === 'string' && pp !== '') ? (isNaN(Number(pp)) ? null : Number(pp)) : (typeof pp === 'number' ? pp : (pp == null ? null : Number(pp)));

    // Determine result if missing, using profit fields
    if (!core.result || core.result === '') {
      if (core.profit != null) {
        core.result = core.profit > 0 ? 'WIN' : (core.profit < 0 ? 'LOSS' : 'DRAW');
      } else if (core.profit_percent != null) {
        core.result = core.profit_percent > 0 ? 'WIN' : (core.profit_percent < 0 ? 'LOSS' : 'DRAW');
      } else if (core.prediction_id && (core.predicted_digit !== null && core.predicted_digit !== undefined)) {
        core.result = 'POSTED';
      } else {
        core.result = 'UNKNOWN';
      }
    } else core.result = String(core.result).toUpperCase();

    // Accept epoch/ts in seconds or ms and normalise timestamp
    try {
      if (core.ts && typeof core.ts === 'number' && core.ts > 1000000000000) core.ts = Math.floor(core.ts/1000);
      if (core.epoch && typeof core.epoch === 'number' && core.epoch > 1000000000000) core.epoch = Math.floor(core.epoch/1000);
      if (!core.timestamp && core.epoch) core.timestamp = core.epoch;
      if (!core.timestamp && core.ts) core.timestamp = core.ts;
    } catch (e) {}

    return core;
  }

  // renderRows preserves scroll when user scrolled down (so journal is scrollable).
  function renderRows(list) {
    if (!list || list.length === 0) {
      journalBody.innerHTML = '<tr><td colspan="9" style="padding:12px;color:#666">No entries in the journal</td></tr>';
      return;
    }
    const container = document.getElementById('journal-main');
    // If user has scrolled down beyond a small threshold, preserve scroll position
    const preserve = container && container.scrollTop > 20;
    const prevScroll = container ? container.scrollTop : 0;

    const toRender = list.slice(0, Math.min(list.length, SESSION_CAP));
    const html = toRender.map(e => {
      const tsPretty = isoShort(e.timestamp || e.ts || e.epoch || '');
      const marketPretty = prettyMarket(e.symbol || e.market || '');
      const pred = (e.predicted_digit ?? e.prediction_digit ?? e.pred ?? e.digit ?? '');
      let actual = '—';
      if (Array.isArray(e.observed_ticks) && e.observed_ticks.length) {
        const last = e.observed_ticks[e.observed_ticks.length-1];
        actual = (typeof last === 'object' ? (last.tick ?? last.value ?? JSON.stringify(last)) : last);
      } else if (typeof e.actual_digit !== 'undefined' && e.actual_digit !== null && e.actual_digit !== '') actual = e.actual_digit;
      const result = (e.result || '').toString().toUpperCase();
      const conf = e.confidence ?? e.conf ?? '';
      const id = e.prediction_id || e.pred_id || e.id || '';

      const profitVal = (typeof e.profit !== 'undefined' && e.profit !== null && !isNaN(Number(e.profit))) ? Number(e.profit) : null;
      const pctVal = (typeof e.profit_percent !== 'undefined' && e.profit_percent !== null && !isNaN(Number(e.profit_percent))) ? Number(e.profit_percent) : null;
      const profitStr = profitVal == null ? '—' : (profitVal >= 0 ? `+${Number(profitVal).toFixed(8).replace(/\.?0+$/,'')}` : `${Number(profitVal).toFixed(8).replace(/\.?0+$/,'')}`);
      const pctStr = pctVal == null ? '—' : (pctVal >= 0 ? `+${Number(pctVal).toFixed(2)}%` : `${Number(pctVal).toFixed(2)}%`);

      let badgeClass='result-unknown', rowClass='';
      if (result==='WIN') { badgeClass='result-win'; rowClass='row-win'; }
      else if (result==='LOSS') { badgeClass='result-loss'; rowClass='row-loss'; }
      else if (result==='DRAW') { badgeClass='result-draw'; rowClass=''; }
      else if (result==='POSTED') { badgeClass='result-posted'; rowClass='row-posted'; }
      const resultBadgeText = result==='WIN' ? '✅ WIN' : (result==='LOSS' ? '❌ LOSS' : (result==='POSTED' ? '• POSTED' : (result==='DRAW' ? '— DRAW' : result || '—')));
      const profitClass = profitVal==null ? 'profit-zero' : (profitVal>0 ? 'profit-positive' : (profitVal<0 ? 'profit-negative' : 'profit-zero'));

      return `<tr class="${rowClass}" title="${String(e.symbol||'')}">
        <td style="padding:8px 10px">${tsPretty}</td>
        <td style="padding:8px 10px;font-weight:700">${marketPretty}</td>
        <td style="padding:8px 10px">${pred}</td>
        <td style="padding:8px 10px">${actual}</td>
        <td style="padding:8px 10px"><span class="result-badge ${badgeClass}">${resultBadgeText}</span></td>
        <td style="padding:8px 10px" class="${profitClass}">${profitStr}</td>
        <td style="padding:8px 10px">${pctStr}</td>
        <td style="padding:8px 10px">${conf}</td>
        <td style="padding:8px 10px">${id}</td>
      </tr>`;
    }).join('');
    journalBody.innerHTML = html;
    // restore or reset scroll appropriately
    if (container) {
      try {
        if (preserve) container.scrollTop = prevScroll;
        else container.scrollTop = 0;
      } catch (e) {}
    }
  }

  function upsertEntry(newEntry) {
    const norm = normalizeItem(newEntry) || {};
    // dedupe by prediction_id when present, else dedupe by market+pred+timestamp close
    if (norm.prediction_id) {
      entries = entries.filter(e => (String(e.prediction_id||e.pred_id||'') !== String(norm.prediction_id)));
    } else {
      entries = entries.filter(e => {
        try {
          const sameMarket = String(e.symbol||e.market||'') === String(norm.symbol||norm.market||'');
          const samePred = String(e.predicted_digit ?? e.prediction_digit ?? e.pred ?? e.digit ?? '') === String(norm.predicted_digit ?? norm.prediction_digit ?? norm.pred ?? norm.digit ?? '');
          const t1 = Number(e.timestamp||e.ts||e.epoch||0);
          const t2 = Number(norm.timestamp||norm.ts||norm.epoch||0);
          const closeTs = Math.abs((t1||0)-(t2||0)) < 2;
          return !(sameMarket && samePred && closeTs);
        } catch (err) { return true; }
      });
    }

    if (norm.prediction_id) {
      for (let i=0;i<entries.length;i++){
        const ex=entries[i];
        if (String(ex.prediction_id||ex.pred_id||'')===String(norm.prediction_id)){
          const merged=Object.assign({}, ex, norm);
          entries.splice(i,1);
          entries.unshift(normalizeItem(merged));
          if (entries.length>SESSION_CAP) entries.length=SESSION_CAP;
          renderRows(entries);
          return;
        }
      }
    }

    // add to front
    entries.unshift(norm);
    if (entries.length>SESSION_CAP) entries.length=SESSION_CAP;
    renderRows(entries);
  }

  async function fetchLastSettled(limit = ROLLING_COUNT) {
    try {
      const res = await fetch(`${JOURNAL_ENDPOINT}?limit=${limit}`, { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const js = await res.json();
      if (!js || !js.ok || !Array.isArray(js.entries)) { statusEl.textContent = 'no journal'; return; }
      const settled = js.entries.map(normalizeItem).filter(Boolean);
      const last = settled.slice(0, limit);
      entries = last;
      renderRows(entries);
      statusEl.textContent = '';
    } catch (err) { console.error('journal fetch error', err); statusEl.textContent = 'history error'; }
  }

  async function clearAll() {
    entries=[]; renderRows(entries); statusEl.textContent='cleared (client)';
    try {
      const res = await fetch('/control/clear_journal', { method: 'POST' });
      statusEl.textContent = res.ok ? 'cleared (server)' : 'cleared (client) — server not cleared';
    } catch (err) { statusEl.textContent = 'cleared (client)'; }
  }

  // Process incoming payload into either POSTED or FINAL entry
  function processIncoming(payload, incomingEventName) {
    if (!payload) return;
    const top = (payload.payload && typeof payload.payload === 'object') ? payload.payload : payload;
    const extracted = {
      prediction_id: top.prediction_id || top.pred_id || top.id || top.prediction || (top.final_contract && top.final_contract.contract_id) || null,
      predicted_digit: top.prediction_digit ?? top.predicted ?? top.pred ?? top.digit ?? null,
      profit: top.profit ?? (top.final_contract && top.final_contract.profit) ?? null,
      profit_percentage: top.profit_percentage ?? top.profitPercent ?? (top.final_contract && top.final_contract.profit_percentage) ?? null,
      result: top.result || top.outcome || top.status || null,
      observed_ticks: top.observed_ticks || top.observed || top.tick_stream || []
    };

    const ae = (top.analysis_event || top.event || top.type || '').toString();
    const resultVal = (top.result || top.outcome || '').toString().toUpperCase();

    const hasFinalContract = Boolean(top.final_contract || top.contract || top.final || (top.status && String(top.status).toLowerCase()==='settled'));
    const isFinal = (ae === 'prediction_result') || (resultVal === 'WIN' || resultVal === 'LOSS' || resultVal === 'DRAW') || hasFinalContract || (top.profit !== undefined && top.profit !== null);

    const isPostedish = (ae === 'prediction_posted' || ae === 'prediction_toast' || (top.status && String(top.status).toLowerCase()==='posted') || (top.status && String(top.status).toLowerCase()==='produced'));
    if (isPostedish && !SHOW_POSTED) {
      addDebugEvent(payload, extracted, 'skipped-posted (SHOW_POSTED=false)');
      return;
    }

    if ((extracted.predicted_digit === null || extracted.predicted_digit === undefined) && !isPostedish) {
      addDebugEvent(payload, extracted, 'skipped-no-predicted-digit');
      return;
    }

    // Derive a prediction_id if missing
    let dedupId = extracted.prediction_id;
    if (!dedupId) {
      try {
        const fc = top.final_contract || top.contract || top.final || top;
        if (fc && (fc.contract_id || fc.contractId)) dedupId = String(fc.contract_id || fc.contractId);
        else if (top.contract_id) dedupId = String(top.contract_id);
        else if (top.transaction_ids && (top.transaction_ids.buy)) dedupId = String(top.transaction_ids.buy);
      } catch (e) { /* ignore */ }
      if (!dedupId) dedupId = `anon_${Math.floor(Date.now()/1000)}_${Math.floor(Math.random()*1000)}`;
    }

    const entryLike = {
      ts: top.ts || top.timestamp || top.epoch || Math.floor(Date.now()/1000),
      epoch: top.epoch || top.ts || Math.floor(Date.now()/1000),
      symbol: top.market || top.symbol || top.market_name || '',
      predicted_digit: Number(extracted.predicted_digit),
      observed_ticks: Array.isArray(extracted.observed_ticks) ? extracted.observed_ticks : (extracted.observed_ticks ? [extracted.observed_ticks] : []),
      result: (top.result || top.outcome || top.status || (isFinal ? (top.profit && Number(top.profit) > 0 ? 'WIN' : (top.profit && Number(top.profit) < 0 ? 'LOSS' : 'DRAW')) : 'POSTED')),
      confidence: top.confidence ?? top.conf ?? null,
      prediction_id: dedupId,
      profit: (extracted.profit !== undefined && extracted.profit !== null) ? Number(extracted.profit) : null,
      profit_percent: (extracted.profit_percentage !== undefined && extracted.profit_percentage !== null) ? Number(extracted.profit_percentage) : null,
      final_contract: top.final_contract || top.contract || top,
      raw: payload
    };

    if (isFinal || SHOW_POSTED) {
      upsertEntry(entryLike);
      addDebugEvent(payload, extracted, `accepted (isFinal=${isFinal})`);
    } else {
      addDebugEvent(payload, extracted, 'skipped-not-final');
    }
  }

  // Setup SSE - listen to analysis *and* default messages (which carry data: {"payload": ...})
  try {
    sse = new EventSource('/events');
    sse.addEventListener('open', () => { console.info('Journal SSE open'); });
    sse.addEventListener('error', (e) => { console.warn('Journal SSE error', e); });

    sse.addEventListener('analysis', (ev) => {
      try {
        const payload = JSON.parse(ev.data || '{}');
        processIncoming(payload, 'analysis');
      } catch (e) {
        console.error('journal SSE parse err (analysis)', e, ev.data);
      }
    });

    sse.addEventListener('message', (ev) => {
      try {
        const payload = JSON.parse(ev.data || '{}');
        processIncoming(payload, 'message');
      } catch (e) {
        console.error('journal SSE parse err (message)', e, ev.data);
      }
    });

    sse.addEventListener('prediction_result', (ev) => {
      try {
        const payload = JSON.parse(ev.data || '{}');
        processIncoming(payload, 'prediction_result');
      } catch (e) {
        console.error('journal SSE parse err (prediction_result)', e, ev.data);
      }
    });

    sse.addEventListener('recent', (ev) => {
      try {
        const obj = JSON.parse(ev.data || '{}');
        if (obj && Array.isArray(obj.recent)) {
          const recs = obj.recent.map(it => {
            if (Array.isArray(it) && it.length >= 7) {
              return {
                timestamp: Number(it[0]),
                price: it[1],
                price_str: it[2],
                full_price: it[3],
                last_decimal: it[4],
                last_unit: it[5],
                symbol: it[6],
                predicted_digit: Number(it[5]) || null,
                observed_ticks: [ { tick: it[3], epoch: Number(it[0]) } ],
                prediction_id: `recent_${it[0]}_${it[6]}`
              };
            }
            return null;
          }).filter(Boolean);
          recs.forEach(r => upsertEntry(r));
        }
      } catch (e) {
        console.warn('recent parse err', e);
      }
    });

  } catch (e) {
    console.error('EventSource init error', e);
    debugSummary.textContent = 'SSE init error — check /events server and CORS';
  }

  function openModal() { modal.style.display='block'; overlay.style.display='block'; modalOpen=true; }
  function closeModal(){ modal.style.display='none'; overlay.style.display='none'; modalOpen=false; }
  document.addEventListener('click',(ev)=>{ const btn = ev.target.closest && ev.target.closest('#journal-header-btn'); if (btn){ ev.preventDefault(); modalOpen?closeModal():openModal(); }});
  if (closeBtn) closeBtn.addEventListener('click', closeModal);
  if (overlay) overlay.addEventListener('click', closeModal);
  if (loadHistoryBtn) loadHistoryBtn.addEventListener('click', ()=> fetchLastSettled(SESSION_CAP));
  if (clearBtn) clearBtn.addEventListener('click', ()=> { if (!confirm('Clear all displayed predictions?')) return; clearAll(); });
  if (debugToggle) debugToggle.addEventListener('click', ()=> { if (debugPanel.style.display==='none'){ debugPanel.style.display='block'; } else debugPanel.style.display='none'; });

  // Polling: auto-refresh the journal every 1000ms (non-blocking).
  // We preserve scroll if the user scrolled down.
  const POLL_MS = 1000;
  let _journalPollTimer = null;
  let _journalIsFetching = false;

  function startJournalPolling() {
    if (_journalPollTimer) return;
    (async () => {
      try {
        if (!_journalIsFetching) {
          _journalIsFetching = true;
          await fetchLastSettled(ROLLING_COUNT);
        }
      } catch (e) {
        console.warn('journal initial fetch failed', e);
      } finally {
        _journalIsFetching = false;
      }
    })();

    _journalPollTimer = setInterval(async () => {
      try {
        if (_journalIsFetching) return;
        _journalIsFetching = true;
        await fetchLastSettled(ROLLING_COUNT);
      } catch (e) {
        console.debug('journal poll error', e);
      } finally {
        _journalIsFetching = false;
      }
    }, POLL_MS);
  }

  function stopJournalPolling() {
    if (_journalPollTimer) {
      clearInterval(_journalPollTimer);
      _journalPollTimer = null;
    }
    _journalIsFetching = false;
  }

  // Start polling immediately
  startJournalPolling();

  window.addEventListener('beforeunload', ()=> {
    if (sse && sse.close) { try { sse.close(); } catch (e) {} }
    try { stopJournalPolling(); } catch (e) {}
  });

});
</script>
