<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HeroX - RDBEAR Live Chart (debug)</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --bg:#f7fafc;
      --card:#ffffff;
      --accent:#2563eb;
      --muted:#6b7280;
      --radius:12px;
      --shadow:0 18px 45px rgba(2,6,23,.08);
    }

    body{ margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:#0f172a; }
    .topbar{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#fff; border-bottom:1px solid #e5e7eb; }
    .topbar h1{ font-size:16px; margin:0; }
    .btn{ padding:8px 14px; border-radius:10px; border:1px solid rgba(2,6,23,.08); background:#f8fafc; cursor:pointer; }
    .btn.primary{ background:var(--accent); color:#fff; border-color:transparent; }
    .btn.ghost{ background:transparent; border:none; color:var(--muted); }
    #container{ padding:14px; display:flex; gap:14px; flex-wrap:wrap; }
    .panel{ background:var(--card); border-radius:var(--radius); padding:14px; box-shadow:var(--shadow); }
    .chart-panel{ flex:1 1 900px; min-width:320px; }
    .side-panel{ width:340px; min-width:240px; display:flex; flex-direction:column; gap:10px; }
    .stat{ font-size:14px; color:var(--muted); }
    .raw{ background:#020617; color:#dbeafe; font-family:monospace; font-size:12px; padding:10px; border-radius:10px; height:320px; overflow:auto; }
    .placeholder { height:480px; display:flex; align-items:center; justify-content:center; color:var(--muted); border: 1px dashed rgba(0,0,0,0.06); border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(248,250,252,0.6)); }
    canvas#chart { width:100%; height:480px; } /* larger height */

    /* indicator side widget under raw */
    #indicator-side {
      background: #fff;
      margin-top: 10px;
      border-radius: 10px;
      padding: 10px;
      color: #0f172a;
      box-shadow: 0 10px 30px rgba(2,6,23,0.06);
      border: 1px solid rgba(0,0,0,0.04);
      font-size: 13px;
    }
    #ind-side-row { display:flex; gap:8px; align-items:center; }
    #ind-side-icon { width:28px; height:28px; display:flex; align-items:center; justify-content:center; border-radius:6px; }
    .ind-up { background:#ecfdf5; color:#065f46; }
    .ind-down { background:#fef2f2; color:#7f1d1d; }
    .ind-neutral { background:#f8fafc; color:#374151; border:1px solid rgba(0,0,0,0.04) }

    .ind-label { font-weight:700; margin-bottom:6px; }
    .ind-values { white-space:pre-wrap; color:#334155; font-family:monospace; font-size:12px; margin-top:6px; }

    /* small controls in side boxes */
    #herox-signal-log { margin-top:10px; }
    #herox-signal-log-body { max-height:120px; overflow:auto; border-radius:8px; }

    /* token toggle */
    .token-toggle {
      display:flex;
      align-items:center;
      gap:10px;
      margin-left:10px;
      font-size:13px;
      color:var(--muted);
    }
    .mode-toggle {
      position:relative;
      width:72px;
      height:30px;
      background:#eef2ff;
      border-radius:16px;
      display:inline-flex;
      align-items:center;
      padding:3px;
      box-sizing:border-box;
      cursor:pointer;
    }
    .mode-toggle .knob {
      width:30px;
      height:24px;
      background:#fff;
      border-radius:12px;
      box-shadow:0 4px 10px rgba(2,6,23,0.08);
      transition: transform .18s ease;
      transform: translateX(0);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
    }
    .mode-toggle.mode-real { background: linear-gradient(90deg,#fff0f0,#ffecec); }
    .mode-toggle.mode-demo { background: linear-gradient(90deg,#ecfdf5,#f0fdf4); }
    .mode-toggle .labels { font-size:11px; color:#475569; display:flex; gap:6px; width:100%; justify-content:space-between; padding:0 6px; pointer-events:none; opacity:0.95; }

    .token-label { font-size:12px; margin-left:8px; color:#475569; }

    /* analysis badge */
    .analysis-badge { margin-left:12px; font-size:13px; color:var(--muted); display:flex; align-items:center; gap:8px; }
    .balances-wrap { display:flex; align-items:center; gap:8px; margin-left:12px; flex-wrap:wrap; }
    .balance-card { display:flex; align-items:center; gap:6px; border-radius:10px; border:1px solid rgba(2,6,23,0.09); background:#f8fafc; padding:6px 10px; line-height:1; }
    .balance-card.demo { border-color:rgba(22,163,74,0.28); background:#f0fdf4; }
    .balance-card.real { border-color:rgba(220,38,38,0.24); background:#fff1f2; }
    .balance-label { font-size:12px; color:#475569; font-weight:600; text-transform:uppercase; letter-spacing:.02em; }
    .balance-value { font-size:13px; color:#0f172a; font-weight:800; font-variant-numeric:tabular-nums; }
    .balance-muted { font-size:12px; color:#64748b; }
    .topbar-balance-toggle { margin-left:6px; }

    .jr-modal{position:fixed;inset:0;background:rgba(2,6,23,.45);display:none;align-items:center;justify-content:center;z-index:1200000}
    .jr-modal.open{display:flex}
    .jr-panel{width:min(980px,94vw);max-height:84vh;background:#fff;border-radius:12px;border:1px solid rgba(2,6,23,.12);box-shadow:0 28px 70px rgba(2,6,23,.35);display:flex;flex-direction:column;overflow:hidden}
    .jr-head{padding:10px 12px;border-bottom:1px solid rgba(2,6,23,.08);display:flex;align-items:center;justify-content:space-between}
    .jr-body{padding:10px;overflow:auto;background:#fbfdff}
    .jr-table{width:100%;border-collapse:collapse;font-size:12px}
    .jr-table th,.jr-table td{padding:8px;border-bottom:1px solid rgba(2,6,23,.08);text-align:left;white-space:nowrap}
    .jr-muted{font-size:12px;color:#64748b}

    @media(max-width:900px){ .chart-panel{ flex-basis:100%; } .side-panel{ width:100%; } }
  </style>
</head>

<body>
<div class="topbar">
  <div style="display:flex;gap:12px;align-items:center">
    <h1>HeroX - RDBEAR Chart (debug)</h1>

    <!-- single Start/Stop toggle -->
    <button id="startStop" class="btn primary">Start Higher-Lower Analysis</button>

    <button id="back" class="btn ghost">Dashboard</button>

    <!-- Balance container + toggle (copied from index.html behavior) -->
    <div id="balancesWrap" class="balances-wrap"></div>
    <button id="btnToggleBalances" class="btn topbar-balance-toggle" title="Toggle balances">Toggle Balances</button>

    <!-- Autotrade toggle -->
    <label style="display:flex;align-items:center;gap:8px;margin-left:10px;font-size:13px;color:var(--muted)">
      <input id="herox-autotrade-checkbox" type="checkbox" style="width:14px;height:14px;cursor:pointer" />
      <span style="font-size:13px">Autotrade</span>
    </label>

    <!-- journal icon button (opens journal modal) -->
    <button id="journal-header-btn" title="Open Prediction Journal" aria-label="Open Prediction Journal" class="btn" style="margin-left:6px;padding:7px 10px;display:inline-flex;align-items:center;justify-content:center">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <rect x="4" y="3" width="16" height="18" rx="2.5" stroke="#0f172a" stroke-width="1.5"/>
        <path d="M8 8h8M8 12h8M8 16h5" stroke="#0f172a" stroke-width="1.5" stroke-linecap="round"/>
      </svg>
    </button>

    <!-- NEW: Token toggle + masked token label -->
    <div id="tokenToggleWrap" class="token-toggle" title="Switch token mode (demo/real)">
      <div id="modeToggle" class="mode-toggle mode-demo" role="button" aria-pressed="false" tabindex="0" title="Toggle demo/real">
        <div class="labels"><span style="opacity:0.85">D</span><span style="opacity:0.85">R</span></div>
        <div class="knob" id="modeKnob">D</div>
      </div>
      <div id="tokenLabel" class="token-label">Using: demo (no token)</div>
    </div>

    <!-- STAKE control (added) -->
    <div style="display:flex;align-items:center;gap:8px;margin-left:12px;">
      <label style="font-size:13px;color:var(--muted);display:flex;align-items:center;gap:6px;">
        Stake
        <input id="stakeInput" type="number" min="0.35" step="0.05" value="1.00" style="width:84px;padding:6px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);font-size:13px" />
      </label>
      <button id="stakeSaveBtn" class="btn" title="Save stake">Save</button>
    </div>

    <!-- analysis counter badge -->
    <div class="analysis-badge" title="Number of analysis events received">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="opacity:0.8"><path d="M3 12h3v7H3zM10 6h3v13h-3zM17 3h3v16h-3z" fill="#6b7280"/></svg>
      <div>Analysis: <strong id="analysisCount">0</strong></div>
    </div>

  </div>
  <div style="font-size:13px;color:var(--muted)">Live via /events - debug logging ON. Open browser console for more details.</div>
</div>


<div id="container">
  <div class="panel chart-panel">
    <div style="display:flex;justify-content:space-between;margin-bottom:8px">
      <strong>RDBEAR Price</strong>
      <span style="color:var(--muted)">x=time | y=price</span>
    </div>

    <div id="chart-wrap" style="position:relative">
      <div id="chart-placeholder" class="placeholder">Waiting for first RDBEAR tick...</div>
      <canvas id="chart" height="480" style="display:none"></canvas>
    </div>
  </div>

  <div class="panel side-panel">
    <div>
      <strong>Stats</strong>
      <div class="stat">Latest: <span id="latest">-</span></div>
      <div class="stat">Points: <span id="count">0</span></div>
      <button id="clear" class="btn" style="margin-top:8px">Clear</button>
    </div>

    <div>
      <strong>Raw SSE</strong>
      <div id="raw" class="raw"></div>

      <!-- Indicator display (UP / DOWN boxes + signal log) -->
      <div id="indicator-side" aria-live="polite" role="status">
        <div class="ind-label">Indicators</div>

        <div id="ind-side-row" style="display:flex;gap:8px;align-items:center;">
          <div id="ind-box-up" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.04);background:#f8fff9;">
            <div style="font-size:12px;color:#065f46;font-weight:700">UPTREND</div>
            <div id="ind-up-percent" style="font-weight:900;font-size:20px">-%</div>
            <div id="ind-up-status" style="font-size:12px;color:#065f46">HOLD</div>
            <div id="ind-up-strength" style="font-size:11px;color:#0f172a;opacity:0.75">-</div>
            <div id="ind-up-timer" style="font-size:11px;color:rgba(0,0,0,0.45)">0s</div>
            <div id="ind-up-note" style="margin-top:6px;font-size:12px;color:#065f46;display:none"></div>
          </div>

          <div id="ind-box-down" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.04);background:#fff7f8;">
            <div style="font-size:12px;color:#7f1d1d;font-weight:700">DOWNTREND</div>
            <div id="ind-down-percent" style="font-weight:900;font-size:20px">-%</div>
            <div id="ind-down-status" style="font-size:12px;color:#7f1d1d">HOLD</div>
            <div id="ind-down-strength" style="font-size:11px;color:#0f172a;opacity:0.75">-</div>
            <div id="ind-down-timer" style="font-size:11px;color:rgba(0,0,0,0.45)">0s</div>
            <div id="ind-down-note" style="margin-top:6px;font-size:12px;color:#7f1d1d;display:none"></div>
          </div>
        </div>

        <!-- Signal Log -->
        <div id="herox-signal-log" style="margin-top:10px;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
            <div style="font-weight:700">Signal Log</div>
            <div>
              <button id="herox-clear-log" style="border-radius:8px;padding:4px 8px;font-size:11px;cursor:pointer">Clear</button>
            </div>
          </div>
          <div id="herox-signal-log-body" style="max-height:120px;overflow:auto;border:1px solid rgba(0,0,0,0.04);padding:6px;border-radius:8px;background:#f8fafc"></div>
        </div>

      </div>
    </div>
  </div>
</div>

<div id="journalModal" class="jr-modal" aria-hidden="true">
  <div class="jr-panel" role="dialog" aria-modal="true" aria-label="Prediction Journal">
    <div class="jr-head">
      <strong>Prediction Journal</strong>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="journalRefreshBtn" class="btn" style="padding:6px 10px">Refresh</button>
        <button id="journalCloseBtn" class="btn" style="padding:6px 10px">Close</button>
      </div>
    </div>
    <div class="jr-body">
      <div id="journalMeta" class="jr-muted">Loading...</div>
      <table class="jr-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Market</th>
            <th>Type</th>
            <th>Result</th>
            <th>Profit</th>
            <th>Confidence</th>
            <th>ID</th>
          </tr>
        </thead>
        <tbody id="journalRows"></tbody>
      </table>
    </div>
  </div>
</div>

<!-- Inline scripts (chart + SSE + trading controls) -->
<script>
(() => {
  const SYMBOL = "RDBEAR";
  const MAX_POINTS = 400;

  // TAKE rule: for testing we take trades if up/down trend >= 65%
  const FORCE_TAKE_THRESHOLD = 0.65; // 65%

  // internal buffer of points {t:ms, v:number}
  window.buffer = window.buffer || [];
  // expose chart globally so other scripts can access it (use heroChart to avoid id collision)
  window.heroChart = window.heroChart || null;

  const canvas = document.getElementById("chart");
  const latestEl = document.getElementById("latest");
  const countEl = document.getElementById("count");
  const rawEl = document.getElementById("raw");
  const placeholder = document.getElementById("chart-placeholder");

  // ---- TOKEN / MODE UI helpers ----
  const tokenLabelEl = document.getElementById('tokenLabel');
  const modeToggleEl = document.getElementById('modeToggle');
  const modeKnobEl = document.getElementById('modeKnob');
  const analysisCountEl = document.getElementById('analysisCount');

  function debugConsole(msg, ...rest){ try { console.debug("[HEROX]", msg, ...rest); } catch(e){} }
  function errorConsole(msg, ...rest){ try { console.error("[HEROX]", msg, ...rest); } catch(e){} }

  // storage keys:
  function maskToken(t){
    if(!t) return null;
    try {
      t = String(t);
      if(t.length <= 8) return t.slice(0,2)+'...'+t.slice(-2);
      return t.slice(0,4) + '...' + t.slice(-4);
    }catch(e){ return null; }
  }

  function setSelectedMode(m){
    try {
      if(m !== 'demo' && m !== 'real') m = 'demo';
      localStorage.setItem('hero_selected_mode', m);
      renderModeUI();
      // fetch balances for selected mode as immediate feedback
      if(window.fetchBalancesForMode) {
        window.fetchBalancesForMode(m).then(r => { rawLog({__meta:'balance_refresh_mode', mode:m, ok: !!r}); });
      }
    }catch(e){}
  }

  function getSelectedMode(){
    try { return localStorage.getItem('hero_selected_mode') || 'demo'; } catch(e){ return 'demo'; }
  }

  // expose to global so other scripts can call it
  window.getSelectedMode = getSelectedMode;

  function renderModeUI(){
    const mode = getSelectedMode();
    const demoPresent = !!localStorage.getItem('hero_token_demo');
    const realPresent = !!localStorage.getItem('hero_token_real');
    const demoMask = localStorage.getItem('hero_token_demo_mask') || null;
    const realMask = localStorage.getItem('hero_token_real_mask') || null;

    if(mode === 'real'){
      modeToggleEl.classList.remove('mode-demo'); modeToggleEl.classList.add('mode-real');
      modeKnobEl.style.transform = 'translateX(40px)'; modeKnobEl.textContent = 'R';
      modeToggleEl.setAttribute('aria-pressed','true');
      tokenLabelEl.textContent = `Using: real ${ realMask ? '('+realMask+')' : (realPresent ? '(present)' : '(no token)') }`;
    } else {
      modeToggleEl.classList.remove('mode-real'); modeToggleEl.classList.add('mode-demo');
      modeKnobEl.style.transform = 'translateX(0)'; modeKnobEl.textContent = 'D';
      modeToggleEl.setAttribute('aria-pressed','false');
      tokenLabelEl.textContent = `Using: demo ${ demoMask ? '('+demoMask+')' : (demoPresent ? '(present)' : '(no token)') }`;
    }
  }

  modeToggleEl.addEventListener('click', function(){
    const cur = getSelectedMode();
    setSelectedMode(cur === 'demo' ? 'real' : 'demo');
  });
  modeToggleEl.addEventListener('keydown', function(e){
    if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); modeToggleEl.click(); }
  });

  // fetch token presence from server and populate localStorage masks
  async function fetchServerTokens(){
    try {
      let j = null;
      try {
        const r = await fetch('/control/get_server_tokens');
        if(r.ok) j = await r.json().catch(()=>null);
      } catch(e){}
      if(!j){
        try {
          const r2 = await fetch('/control/get_tokens');
          if(r2.ok) j = await r2.json().catch(()=>null);
        } catch(e){}
      }
      if(!j){
        try {
          const r3 = await fetch('/control/get_token');
          if(r3.ok) j = await r3.json().catch(()=>null);
        } catch(e){}
      }
      if(j && j.ok){
        try {
          if(j.tokens){ // /control/get_server_tokens shape
            const t = j.tokens;
            if(t.demo && t.demo.present){ localStorage.setItem('hero_token_demo', '1'); localStorage.setItem('hero_token_demo_mask', t.demo.masked || t.demo.mask || ''); }
            if(t.real && t.real.present){ localStorage.setItem('hero_token_real', '1'); localStorage.setItem('hero_token_real_mask', t.real.masked || t.real.mask || ''); }
          } else if('demo_present' in j || 'demo_mask' in j){ // older shape
            if(j.demo_present) { localStorage.setItem('hero_token_demo', '1'); localStorage.setItem('hero_token_demo_mask', j.demo_mask || j.demo_masked || ''); }
            if(j.real_present) { localStorage.setItem('hero_token_real', '1'); localStorage.setItem('hero_token_real_mask', j.real_mask || j.real_masked || ''); }
          }
        } catch(e){}
      }
      renderModeUI();
      rawLog({__meta:'fetched_server_tokens', tokens_found: !!j});
      debugConsole("fetchServerTokens result", j);
      // If server has token(s) present, start polling balances in header
      try {
        const hasTokens = !!localStorage.getItem('hero_token_demo') || !!localStorage.getItem('hero_token_real');
        if(hasTokens) startHeaderBalancePolling();
      } catch(e){}
      return j;
    } catch(e){
      rawLog({__err:'fetch_server_tokens_failed', e:String(e)});
      errorConsole("fetchServerTokens failed", e);
      return null;
    }
  }

  window.__hero_reload_tokens = fetchServerTokens;

  // ---- end token / mode helpers ----

  function rawLog(obj){
    try {
      const d = document.createElement("div");
      d.textContent = JSON.stringify(obj);
      rawEl.appendChild(d);
      rawEl.scrollTop = rawEl.scrollHeight;
      while(rawEl.children.length > 800) rawEl.removeChild(rawEl.firstChild);
      // also output to console for easier debugging
      console.debug("[HEROX raw]", obj);
    } catch(e){}
  }

  function appendSignalLog(txt) {
    try {
      const body = document.getElementById('herox-signal-log-body');
      if(!body) return;
      const el = document.createElement('div');
      el.style.borderBottom = '1px solid rgba(0,0,0,0.04)';
      el.style.padding = '6px 4px';
      el.style.fontSize = '12px';
      el.style.whiteSpace = 'pre-wrap';
      el.textContent = `[${(new Date()).toLocaleTimeString()}] ${txt}`;
      body.insertBefore(el, body.firstChild);
      while(body.children.length > 20) body.removeChild(body.lastChild);
    } catch(e){}
  }

  function formatPriceForLabel(v){
    if(v === null || v === undefined || Number.isNaN(v)) return String(v);
    return parseFloat(Number(v).toFixed(5)).toString();
  }

  function createChart(initialPrice){
    try {
      // make visible first
      placeholder.style.display = "none";
      canvas.style.display = "block";
      // ensure CSS sizing exists
      canvas.style.width = '100%';
      canvas.style.height = '480px';
      // force canvas pixel size to match client size (helps Chart.js compute correctly)
      const cw = Math.max(200, Math.floor(canvas.clientWidth || canvas.offsetWidth || 800));
      canvas.width = cw;
      canvas.height = 480;
    } catch(e){ console.warn("createChart make-visible failed", e); }

    try {
      const ctx2 = canvas.getContext ? canvas.getContext('2d') : null;
      if(!ctx2) { console.error("createChart: no 2d context"); return null; }
      if(typeof Chart === 'undefined'){ console.error("createChart: Chart.js missing"); return null; }

      // plugin that draws label for last point
      const lastPointLabelPlugin = {
        id: 'lastPointLabel',
        afterDatasetsDraw(chart) {
          try {
            const meta = chart.getDatasetMeta(0);
            if(!meta || !meta.data || meta.data.length === 0) return;
            const lastEl = meta.data[meta.data.length - 1];
            if(!lastEl) return;
            const ctx = chart.ctx;
            const padding = 6;
            const txt = (function(){
              const val = chart.data.datasets[0].data[meta.data.length - 1];
              const lbl = chart.data.labels[meta.data.length - 1] || '';
              return `${lbl} | ${Number(val).toFixed(5)}`;
            })();

            ctx.save();
            ctx.font = '12px Inter, Arial, sans-serif';
            ctx.textBaseline = 'bottom';
            // small white background for legibility
            const txtWidth = ctx.measureText(txt).width;
            // place label to the left if near right edge
            const canvasW = chart.width || (chart.canvas && chart.canvas.width) || 0;
            let x = lastEl.x + 8;
            const y = lastEl.y - 8;
            if (x + txtWidth + padding > canvasW) {
              x = lastEl.x - txtWidth - padding - 8;
            }
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.fillRect(x - padding/2, y - 16, txtWidth + padding, 18);
            ctx.fillStyle = '#0f172a';
            ctx.fillText(txt, x + 2, y - 2);
            ctx.restore();
          } catch(e) {
            // ignore plugin draw errors
          }
        }
      };

      // debug: report measurements when creating chart
      console.debug("[HEROX createChart] initialPrice", initialPrice, "canvas.clientWidth", canvas.clientWidth, "canvas.width", canvas.width);

      window.heroChart = new Chart(ctx2, {
        type: 'line',
        data: {
          labels: buffer.map(p => new Date(p.t).toLocaleTimeString()),
          datasets: [{
            label: SYMBOL,
            data: buffer.map(p => p.v),
            borderWidth: 1.8,
            tension: 0.2,
            // scriptable pointRadius: only last point visible
            pointRadius: function(context) {
              const idx = context.dataIndex;
              const len = context.dataset.data.length;
              return (idx === len - 1) ? 4 : 0;
            },
            pointHoverRadius: 6,
            hitRadius: 6,
            fill: false,
            borderColor: '#0f172a'
          }]
        },
        options: {
          animation: { duration: 200 }, // short animation for rolling look
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Time' },
              ticks: { autoSkip: true, maxTicksLimit: 8 }
            },
            y: {
              title: { display: true, text: 'Price' },
              ticks: { maxTicksLimit: 8, callback: (v) => formatPriceForLabel(v) },
              min: initialPrice - (Math.abs(initialPrice) * 0.002 || 0.01),
              max: initialPrice + (Math.abs(initialPrice) * 0.002 || 0.01)
            }
          },
          plugins: {
            legend: { display: true }
          }
        },
        plugins: [lastPointLabelPlugin]
      });

      // small delay then force resize/update to make sure Chart.js re-measures after layout
      setTimeout(() => {
        try {
          if (window.heroChart && typeof window.heroChart.resize === 'function') window.heroChart.resize();
          if (window.heroChart && typeof window.heroChart.update === 'function') window.heroChart.update();
        } catch (e) { console.warn("chart resize/update failed", e); }
      }, 60);

      return window.heroChart;
    } catch(e){
      console.error("createChart failed", e);
      return null;
    }
  }

  let lastY = {min: null, max: null};
  function updateYAxisIfNeeded(){
    try {
      if(!window.heroChart || !window.heroChart.options || !window.heroChart.options.scales || buffer.length < 3) return;
      const prices = buffer.map(p => p.v);
      const min = Math.min(...prices);
      const max = Math.max(...prices);
      const pad = (max - min) * 0.18 || Math.max(Math.abs(max) * 0.001, 0.01);
      const candidateMin = min - pad;
      const candidateMax = max + pad;
      const expandMargin = (Math.abs(candidateMax - candidateMin)) * 0.02;
      if (lastY.min === null || lastY.max === null) {
        window.heroChart.options.scales.y.min = candidateMin;
        window.heroChart.options.scales.y.max = candidateMax;
        lastY = {min: candidateMin, max: candidateMax};
        return;
      }
      if(candidateMin < lastY.min - 1e-12 || candidateMax > lastY.max + 1e-12){
        window.heroChart.options.scales.y.min = candidateMin;
        window.heroChart.options.scales.y.max = candidateMax;
        lastY = {min: candidateMin, max: candidateMax};
        return;
      }
      const lastRange = lastY.max - lastY.min;
      const candRange = candidateMax - candidateMin;
      if(candRange < lastRange - expandMargin){
        window.heroChart.options.scales.y.min = candidateMin;
        window.heroChart.options.scales.y.max = candidateMax;
        lastY = {min: candidateMin, max: candidateMax};
      }
    } catch(e){
      // safe ignore update errors
      console.warn("updateYAxisIfNeeded error", e);
    }
  }

  function ensureChartDataStructure(){
    try {
      if(!window.heroChart) return false;
      if(!window.heroChart.data) window.heroChart.data = { labels: [], datasets: [{ label: SYMBOL, data: [] }] };
      if(!Array.isArray(window.heroChart.data.datasets) || window.heroChart.data.datasets.length === 0){
        window.heroChart.data.datasets = [{ label: SYMBOL, data: [] }];
      }
      if(!Array.isArray(window.heroChart.data.labels)) window.heroChart.data.labels = [];
      if(!Array.isArray(window.heroChart.data.datasets[0].data)) window.heroChart.data.datasets[0].data = [];
      return true;
    } catch(e){ console.warn("ensureChartDataStructure failed", e); return false; }
  }

  // ------------------- HeroX helpers: tick counter & chart-init watcher -------------------
  // tick counter increments once per addPoint() call - used for tick-based cooldowns
  window.__herox_tick_counter = window.__herox_tick_counter || 0;
  // last TAKE tick index (used to enforce N-tick separation)
  window.__herox_last_take_tick = window.__herox_last_take_tick || -9999;

  // chart-init watcher id (so we can cancel it on stop)
  let __herox_chart_init_interval = null;

  function startChartInitWatcher(){
    if(__herox_chart_init_interval) return;
    __herox_chart_init_interval = setInterval(() => {
      try {
        if(!window.heroChart && Array.isArray(window.buffer) && window.buffer.length){
          // create chart using last known price
          createChart(window.buffer[window.buffer.length-1].v || window.buffer[0].v || 0);
          ensureChartDataStructure();
          if(window.heroChart) {
            window.heroChart.data.labels = buffer.map(p => new Date(p.t).toLocaleTimeString());
            window.heroChart.data.datasets[0].data = buffer.map(p => p.v);
            try { window.heroChart.update(); } catch(e){}
            lastY = { min: (window.heroChart.options && window.heroChart.options.scales && window.heroChart.options.scales.y && window.heroChart.options.scales.y.min) || null, max: (window.heroChart.options && window.heroChart.options.scales && window.heroChart.options.scales.y && window.heroChart.options.scales.y.max) || null };
          }
          clearInterval(__herox_chart_init_interval);
          __herox_chart_init_interval = null;
        }
      } catch(e){
        // ignore
      }
    }, 400);
  }
  function stopChartInitWatcher(){
    if(__herox_chart_init_interval){ clearInterval(__herox_chart_init_interval); __herox_chart_init_interval = null; }
  }

  // stop SSE helper
  function stopSSE(){
    try {
      if(es){ try { es.close(); } catch(e){} }
    } catch(e){}
    es = null;
    debugConsole("EventSource stopped");
  }

  function addPoint(epochSeconds, price){
    if(price === null || price === undefined || Number.isNaN(price)) return;
    const ts = Math.floor(Number(epochSeconds) * 1000);
    buffer.push({ t: ts, v: Number(price) });
    if(buffer.length > MAX_POINTS) buffer.shift();

    // increment tick counter (used for tick-based spacing between signals)
    window.__herox_tick_counter = (window.__herox_tick_counter || 0) + 1;

    // ensure chart exists (if not, start watcher which will create it when buffer non-empty)
    if(!window.heroChart){
      // try immediate create if possible, otherwise rely on watcher
      const c = createChart(Number(price));
      if(!c){
        startChartInitWatcher();
        latestEl.textContent = formatPriceForLabel(price);
        countEl.textContent = String(buffer.length);
        return;
      }
      ensureChartDataStructure();
      window.heroChart.data.labels = buffer.map(p => new Date(p.t).toLocaleTimeString());
      window.heroChart.data.datasets[0].data = buffer.map(p => p.v);
      try { window.heroChart.update(); } catch(e){}
      lastY = { min: (window.heroChart.options && window.heroChart.options.scales && window.heroChart.options.scales.y && window.heroChart.options.scales.y.min) || null, max: (window.heroChart.options && window.heroChart.options.scales && window.heroChart.options.scales.y && window.heroChart.options.scales.y.max) || null };
    } else {
      ensureChartDataStructure();
      try {
        const ds = window.heroChart.data.datasets[0];
        window.heroChart.data.labels.push(new Date(ts).toLocaleTimeString());
        ds.data.push(Number(price));
        if(ds.data.length > MAX_POINTS){
          ds.data.shift();
          window.heroChart.data.labels.shift();
        }
        updateYAxisIfNeeded();
        // animate a little so chart visibly rolls
        window.heroChart.update();
      } catch(e){
        // fallback: full replace if incremental fails
        window.heroChart.data.labels = buffer.map(p => new Date(p.t).toLocaleTimeString());
        window.heroChart.data.datasets[0].data = buffer.map(p => p.v);
        updateYAxisIfNeeded();
        try { window.heroChart.update(); } catch(e){}
      }
    }

    latestEl.textContent = formatPriceForLabel(price);
    countEl.textContent = String(buffer.length);

    // server-side pipeline handles analysis persistence and enrichment
  }

  // friendly price extraction; prefer full price fields
  function extractPrice(payload){
    if(!payload || typeof payload !== 'object') return null;
    const candidates = ['price','last_price','quote','mid','close','ask','bid'];
    for(const k of candidates){
      if(payload[k] !== undefined && payload[k] !== null && payload[k] !== ''){
        const n = Number(payload[k]);
        if(!Number.isNaN(n)) return n;
      }
    }
    // observed_ticks fallback
    if(Array.isArray(payload.observed_ticks) && payload.observed_ticks.length){
      const last = payload.observed_ticks[payload.observed_ticks.length - 1];
      if(last){
        const cand = last.quote ?? last.price ?? last.close ?? last.last_price;
        const n = Number(cand);
        if(!Number.isNaN(n)) return n;
      }
    }
    return null;
  }

  // SSE
  let es = null;
  function startSSE(){
    if(es) return;
    try { 
      es = new EventSource('/events');
      debugConsole("EventSource created -> /events");
    } catch(e){ rawLog({__err:'sse_start_failed', e:String(e)}); es=null; setTimeout(startSSE,2000); return; }
    es.onopen = ()=> {
      rawLog({__meta:'sse_open', ts: new Date().toISOString()});
      debugConsole("SSE open");
    };

    es.addEventListener('message', ev => {
      if(!ev.data) return;
      try {
        const parsed = JSON.parse(ev.data);
        const payload = parsed.payload || parsed;
        debugConsole("SSE message", payload);
        handleIncoming(payload);
        rawLog({type:'message', payload});
      } catch(e){ rawLog({__err:'parse_message', raw: ev.data}); errorConsole("parse_message", e, ev.data); }
    });

    es.addEventListener('analysis', ev => {
      if(!ev.data) return;
      try {
        const payload = JSON.parse(ev.data);
        // increment analysis counter if it looks like an analysis event
        try {
          if(payload && (payload.analysis_event || payload.event)) {
            const n = Number(analysisCountEl.textContent || 0) + 1;
            analysisCountEl.textContent = String(n);
          }
        } catch(e){}
        debugConsole("SSE analysis", payload);
        updateTradeGateFromAnalysisPayload(payload);
        handleIncoming(payload);
        const reason = payload.reason || payload.indicators || null;
        rawLog({type:'analysis', payload, reason});
      } catch(e){ rawLog({__err:'parse_analysis', raw: ev.data}); errorConsole("parse_analysis", e, ev.data); }
    });

    es.addEventListener('prediction_result', ev => {
      if(!ev.data) return;
      try {
        const payload = JSON.parse(ev.data);
        updateTradeGateFromAnalysisPayload(payload);
        rawLog({type:'prediction_result', payload});
      } catch(e){ rawLog({__err:'parse_prediction_result', raw: ev.data}); }
    });

    es.addEventListener('recent', ev => {
      if(!ev.data) return;
      try {
        const obj = JSON.parse(ev.data || '{}');
        debugConsole("SSE recent payload", obj);
        if(obj && Array.isArray(obj.recent)){
          obj.recent.forEach(row => {
            try {
              if(Array.isArray(row) && row.length >= 7){
                const sym = (row[6] || '').toString().toUpperCase();
                if(sym !== SYMBOL) return;
                // Prefer server epoch on row[0] if present
                const epochCandidate = Number(row[0]) || (Date.now()/1000);
                // Use row[3] (close) only (last_decimal disabled)
                const price = (row[3] !== "" && row[3] !== undefined) ? Number(row[3]) : null;
                if(price !== null && !Number.isNaN(price)) {
                  addPoint(epochCandidate, price);
                }
              }
            } catch(e){ errorConsole("recent handler row parse", e); }
          });
        }
      } catch(e){ errorConsole("parse recent", e); }
    });

    es.onerror = (e) => {
      rawLog({__meta:'sse_error', e:String(e)});
      errorConsole("SSE error", e);
      try { es.close(); } catch(_) {}
      es = null;
      setTimeout(startSSE, 2000);
    };
  }

  function handleIncoming(payload){
    if(!payload || typeof payload !== 'object') return;
    // keep last analysis payload (for journal fallback)
    try { window.__hero_last_analysis_payload = payload; } catch(e){}
    const sym = (payload.symbol || payload.market || payload.market_code || payload.symbol_code || '').toString().toUpperCase() || null;
    const price = extractPrice(payload);
    const epoch = payload.epoch || payload.ts || payload.timestamp || (Date.now()/1000);
    debugConsole("handleIncoming", {sym, price, epoch, payload});
    rawLog({__meta:'incoming', sym, price});
    if(sym && sym !== SYMBOL) {
      debugConsole("incoming symbol mismatch, ignoring", sym);
      return;
    }
    if(price !== null && !Number.isNaN(price)) addPoint(epoch, price);
  }

  // start SSE immediately
  startSSE();

  // Journal modal
  const journalBtn = document.getElementById('journal-header-btn');
  const journalModal = document.getElementById('journalModal');
  const journalRows = document.getElementById('journalRows');
  const journalMeta = document.getElementById('journalMeta');
  const journalCloseBtn = document.getElementById('journalCloseBtn');
  const journalRefreshBtn = document.getElementById('journalRefreshBtn');

  function normJournalEntry(e){
    const raw = (e && typeof e === 'object') ? e : {};
    const nested = (raw.entry && typeof raw.entry === 'object') ? raw.entry : {};
    return {
      ts: raw.ts || raw.timestamp || nested.timestamp || null,
      market: raw.market || raw.symbol || nested.symbol || '-',
      tradeType: raw.trade_type || raw.direction || raw.type || nested.trade_type || nested.direction || '-',
      result: raw.result || nested.result || '-',
      profit: raw.profit ?? nested.profit ?? null,
      conf: raw.conf ?? raw.confidence ?? nested.confidence ?? null,
      id: raw.id || raw.prediction_id || nested.prediction_id || '-'
    };
  }

  function renderJournal(entries){
    if(!journalRows) return;
    journalRows.innerHTML = '';
    if(!Array.isArray(entries) || entries.length === 0){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 7;
      td.textContent = 'No journal entries yet.';
      tr.appendChild(td);
      journalRows.appendChild(tr);
      if(journalMeta) journalMeta.textContent = '0 entries';
      return;
    }
    entries.forEach((x) => {
      const e = normJournalEntry(x);
      const tr = document.createElement('tr');
      const dt = e.ts ? new Date(Number(e.ts) * 1000) : null;
      const vals = [
        dt ? dt.toLocaleString() : '-',
        e.market,
        String(e.tradeType || '-').toUpperCase(),
        String(e.result || '-').toUpperCase(),
        (e.profit === null || e.profit === undefined || Number.isNaN(Number(e.profit))) ? '-' : Number(e.profit).toFixed(2),
        (e.conf === null || e.conf === undefined || Number.isNaN(Number(e.conf))) ? '-' : `${(Number(e.conf) * 100).toFixed(1)}%`,
        e.id
      ];
      vals.forEach(v => {
        const td = document.createElement('td');
        td.textContent = String(v);
        tr.appendChild(td);
      });
      journalRows.appendChild(tr);
    });
    if(journalMeta) journalMeta.textContent = `${entries.length} entries`;
  }

  async function loadJournal(){
    try {
      if(journalMeta) journalMeta.textContent = 'Loading...';
      const r = await fetch('/control/journal?limit=120', { headers: { 'Accept': 'application/json' } });
      const j = await r.json().catch(()=>null);
      const entries = (j && Array.isArray(j.entries)) ? j.entries : [];
      renderJournal(entries);
    } catch (e) {
      renderJournal([]);
      if(journalMeta) journalMeta.textContent = `Journal load failed: ${String(e && e.message ? e.message : e)}`;
    }
  }

  function openJournal(){
    if(!journalModal) return;
    journalModal.classList.add('open');
    journalModal.setAttribute('aria-hidden', 'false');
    loadJournal();
  }
  function closeJournal(){
    if(!journalModal) return;
    journalModal.classList.remove('open');
    journalModal.setAttribute('aria-hidden', 'true');
  }
  if(journalBtn) journalBtn.addEventListener('click', openJournal);
  if(journalCloseBtn) journalCloseBtn.addEventListener('click', closeJournal);
  if(journalRefreshBtn) journalRefreshBtn.addEventListener('click', loadJournal);
  if(journalModal) journalModal.addEventListener('click', (e) => { if(e.target === journalModal) closeJournal(); });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && journalModal && journalModal.classList.contains('open')) closeJournal();
  });

  // Buttons & helpers
  async function post(url, body){
    try {
      const r = await fetch(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body||{}) });
      const j = await r.json().catch(()=>null);
      rawLog({__meta:'post', url, status: r.status, resp: j});
      debugConsole("POST", url, body, "->", r.status, j);
      return j;
    } catch(e){ rawLog({__err:'post_failed', url, e: String(e)}); errorConsole("post_failed", url, e); return null; }
  }

  // Hook up Start/Stop Higher-Lower analysis (tick stream stays independent).
  const startStopBtn = document.getElementById('startStop');
  let hlAnalysisRunning = false;
  window.__hlAnalysisRunning = false;
  async function startCharts(){
    try {
      startStopBtn.disabled = true;
      hlAnalysisRunning = true;
      window.__hlAnalysisRunning = true;
      startStopBtn.textContent = 'Stop Higher-Lower Analysis';
      rawLog({__meta:'hl_analysis_started', symbol: SYMBOL});
    } finally {
      startStopBtn.disabled = false;
    }
  }
  async function stopCharts(){
    try {
      startStopBtn.disabled = true;
      hlAnalysisRunning = false;
      window.__hlAnalysisRunning = false;
      rawLog({__meta:'hl_analysis_stopped', symbol: SYMBOL});
      if (window.clearTradePending) window.clearTradePending('analysis_stopped');
    } finally {
      startStopBtn.disabled = false;
      startStopBtn.textContent = 'Start Higher-Lower Analysis';
    }
  }

  startStopBtn.addEventListener('click', function(){
    try {
      if(!window.__hlAnalysisRunning) startCharts();
      else stopCharts();
    } catch(e){ errorConsole("startStop click error", e); }
  });
// Clear button
  document.getElementById('clear').onclick = () => {
    buffer.length = 0;
    if(window.heroChart){ window.heroChart.data.labels=[]; window.heroChart.data.datasets[0].data=[]; window.heroChart.update(); }
    else { placeholder.style.display = ''; canvas.style.display = 'none'; }
    latestEl.textContent = '-';
    countEl.textContent = '0';
    const vs = document.getElementById('ind-side-values'); if(vs) vs.textContent = 'Waiting for data...';
    const tr = document.getElementById('ind-side-trend'); if(tr) tr.textContent = 'Trend: -';
    const ic = document.getElementById('ind-side-icon'); if(ic){ ic.className = 'ind-neutral'; ic.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none"><rect x="2" y="11" width="20" height="2" rx="1" fill="#374151"></rect></svg>'; }
  };
  document.getElementById('back').onclick = () => { window.location.href = '/'; };

  // debug manual push helper
  window.__herox_push_tick = function(obj){
    try {
      if(!obj || !obj.symbol) return;
      const p = { symbol: obj.symbol, price: obj.price ?? obj.last_price ?? obj.close ?? obj.quote ?? null, epoch: obj.epoch ?? (Date.now()/1000) };
      handleIncoming(p);
      rawLog({__meta:'manual_push', p});
    } catch(e){}
  };

  // AUTOTRADE UI storage key (keeps toggle state across reloads)
  const AUTOTRADE_STORAGE_KEY = 'herox_autotrade_enabled';

  // init autotrade checkbox with saved value
  try {
    const cb = document.getElementById('herox-autotrade-checkbox');
    const saved = localStorage.getItem(AUTOTRADE_STORAGE_KEY) === '1';
    if(cb) {
      cb.checked = saved;
      cb.addEventListener('change', () => {
        try { localStorage.setItem(AUTOTRADE_STORAGE_KEY, cb.checked ? '1' : '0'); } catch(e){}
      });
    }
  } catch(e){}

  // shorthand: return boolean
  function isAutoTradeEnabled() {
    try { return localStorage.getItem(AUTOTRADE_STORAGE_KEY) === '1'; } catch(e){ return false; }
  }

  const TRADE_LOCK_MAX_MS = 45000;
  window.__herox_trade_gate = {
    pending: false,
    prediction_id: null,
    started_at: 0,
    last_result: null
  };

  function appendTradeGateLog(msg) {
    try {
      if (typeof window.signalLogAppend === 'function') window.signalLogAppend(msg);
    } catch (e) {}
  }

  function setTradePending(predictionId) {
    window.__herox_trade_gate.pending = true;
    window.__herox_trade_gate.prediction_id = predictionId || null;
    window.__herox_trade_gate.started_at = Date.now();
  }

  function clearTradePending(resultLabel) {
    window.__herox_trade_gate.pending = false;
    window.__herox_trade_gate.prediction_id = null;
    window.__herox_trade_gate.started_at = 0;
    window.__herox_trade_gate.last_result = resultLabel || null;
  }

  function isTradePending() {
    const gate = window.__herox_trade_gate || {};
    if (!gate.pending) return false;
    const started = Number(gate.started_at || 0);
    if (started > 0 && (Date.now() - started) > TRADE_LOCK_MAX_MS) {
      clearTradePending('timeout_release');
      appendTradeGateLog('Pending trade lock timed out; auto-released.');
      return false;
    }
    return true;
  }

  function updateTradeGateFromAnalysisPayload(payload) {
    try {
      const p = payload || {};
      const eventName = String(p.analysis_event || p.event || '').toLowerCase();
      const pid = p.prediction_id || p.id || null;
      const result = String(p.result || p.outcome || p.status || '').toUpperCase();
      const settled = (p.settled === true) || (result === 'WIN' || result === 'LOSS') || (eventName === 'prediction_result') || (eventName === 'contract_settled');
      if (!settled) return;
      if (!window.__herox_trade_gate.pending) return;
      if (window.__herox_trade_gate.prediction_id && pid && String(window.__herox_trade_gate.prediction_id) !== String(pid)) return;
      clearTradePending(result || 'SETTLED');
      appendTradeGateLog(`Previous trade settled (${result || 'SETTLED'}) | new trades enabled`);
    } catch (e) {}
  }

  window.setTradePending = setTradePending;
  window.clearTradePending = clearTradePending;
  window.isTradePending = isTradePending;
  window.updateTradeGateFromAnalysisPayload = updateTradeGateFromAnalysisPayload;

  async function pushAssistantAnalysisEvent(eventPayload) {
    try {
      if (!eventPayload || !eventPayload.analysis_event) return;
      await fetch('/control/push_tick', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          epoch: Math.floor(Date.now() / 1000),
          symbol: 'ANALYSIS',
          payload: eventPayload
        })
      });
    } catch (e) {
      rawLog({__meta: 'assistant_event_push_failed', error: String(e)});
    }
  }

  // send trade payload to hero_service endpoint (server will validate/forward)
  window.sendTradePayload = async function(payload) {
    try {
      const req = Object.assign({}, payload || {});
      if (!req.prediction_id) {
        req.prediction_id = `ui_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      }
      if (isTradePending()) {
        const blockedPid = window.__herox_trade_gate.prediction_id || 'pending';
        rawLog({__meta: 'send_trade_blocked_pending', blocked_by: blockedPid, payload: req});
        return { ok: false, status: 409, blocked: true, reason: 'trade_pending', blocked_by: blockedPid };
      }
      setTradePending(req.prediction_id);

      // log to raw panel
      rawLog({__meta: 'send_trade_payload', payload: req});
      // send to /trader/signal (blueprint added) - forced trades from front-end include "force": true
      const r = await fetch('/trader/signal', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(req)
      });
      const j = await r.json().catch(()=>null);
      rawLog({__meta:'send_trade_resp', status: r.status, body: j});
      debugConsole("sendTradePayload resp", r.status, j);

      if (r.ok && j && j.ok) {
        await pushAssistantAnalysisEvent({
          analysis_event: 'trade_posted',
          prediction_id: req.prediction_id,
          symbol: req.symbol,
          direction: req.direction || req.signal,
          trade_type: req.direction || req.signal,
          contract_type: req.contract_type,
          confidence: req.confidence,
          reason: req.reason || null,
          indicators: (req.reason && req.reason.indicators) ? req.reason.indicators : null,
          mode: req.mode,
          stake: req.stake,
          duration: req.duration,
          duration_unit: req.duration_unit
        });
      }

      await pushAssistantAnalysisEvent({
        analysis_event: 'trade_update',
        prediction_id: req.prediction_id,
        symbol: req.symbol,
        direction: req.direction || req.signal,
        trade_type: req.direction || req.signal,
        contract_type: req.contract_type,
        confidence: req.confidence,
        reason: req.reason || null,
        indicators: (req.reason && req.reason.indicators) ? req.reason.indicators : null,
        mode: req.mode,
        stake: req.stake,
        duration: req.duration,
        duration_unit: req.duration_unit,
        settled: j && j.settled,
        contract_id: j && j.contract_id,
        result: j && (j.result || j.outcome || j.status),
        profit: j && j.profit,
        contract_status: j && j.contract_status,
        http_status: r.status
      });

      const resultLabel = String((j && (j.result || j.outcome || j.status)) || '').toUpperCase();
      const settledNow = !!((j && j.settled === true) || (resultLabel === 'WIN' || resultLabel === 'LOSS'));
      if (settledNow) {
        clearTradePending(resultLabel || 'SETTLED');
      }

      return { ok: r.ok, status: r.status, json: j, prediction_id: req.prediction_id };
    } catch (e) {
      clearTradePending('ERROR');
      rawLog({__err:'send_trade_failed', e: String(e)});
      errorConsole("sendTradePayload failed", e);
      return { ok: false, error: String(e) };
    }
  };

  // initialize token UI & fetch server tokens on load
  (async function initTokensAndMode(){
    try {
      // fetch server tokens (if hero_service has them)
      await fetchServerTokens();
      // if no selected mode exists, prefer demo
      if(!localStorage.getItem('hero_selected_mode')) localStorage.setItem('hero_selected_mode','demo');
      renderModeUI();
    } catch(e){ rawLog({__err:'init_tokens_failed', e:String(e)}); errorConsole("initTokens failed", e); }
  })();

  // ---- Balance polling helpers (existing code uses localStorage hero_token_demo|real keys) ----
  async function fetchBalancesForMode(mode){
    try{
      const url = '/control/get_balances?mode=' + encodeURIComponent(mode);
      const r = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
      if(!r.ok) return null;
      const j = await r.json().catch(()=>null);
      if(!j) return null;
      const obj = j.balance || j.balances || j;
      try { localStorage.setItem('hero_balance_' + mode, JSON.stringify(obj)); } catch(e){}
      applyToDOM(mode, obj);
      return obj;
    }catch(e){
      errorConsole("fetchBalancesForMode failed", e);
      return null;
    }
  }

  // expose so other scripts can call fetchBalancesForMode without ReferenceError
  window.fetchBalancesForMode = fetchBalancesForMode;

  // Keep header cards updated when localStorage changes from other tabs
  window.addEventListener('storage', function(e){
    if(!e) return;
    if(e.key && (e.key.startsWith('hero_token_') || e.key.startsWith('hero_balance_'))){
      try { fetchServerTokens(); } catch(e){}
      try {
        const hasDemo = !!localStorage.getItem('hero_token_demo');
        const hasReal = !!localStorage.getItem('hero_token_real');
        if(hasDemo || hasReal) startHeaderBalancePolling();
        else stopHeaderBalancePolling();
      } catch(e){}
    }
  });

  window.__hero_apply_saved_balances = function(){ loadSavedBalances(); };

  // ---------- rest of your indicator code unchanged ----------
  // (The computeIndicatorsFromBuffer + voteSignal engine below MUST be present before the indicator loop.)

})();
</script>

<!-- Indicator engine: computeIndicatorsFromBuffer + voteSignal (must run before the indicator loop) -->
<script>
/* ---------- Indicator engine: computeIndicatorsFromBuffer + voteSignal ---------- */
/* (unchanged from your working engine - keeps EMA, MACD hist, ATR, RSI, BB) */
function sma(values, period) {
  const out = [];
  for (let i = 0; i < values.length; i++) {
    if (i + 1 < period) { out.push(null); continue; }
    let sum = 0;
    for (let j = i - period + 1; j <= i; j++) sum += values[j];
    out.push(sum / period);
  }
  return out;
}
function emaArray(values, period) {
  const out = [];
  const k = 2 / (period + 1);
  let prev = null;
  for (let i = 0; i < values.length; i++) {
    const v = values[i];
    if (v === null || v === undefined) { out.push(null); continue; }
    if (prev === null) {
      if (i + 1 >= period) {
        let sum = 0;
        for (let j = i - period + 1; j <= i; j++) sum += values[j];
        prev = sum / period;
      } else {
        prev = v;
      }
      out.push(prev);
    } else {
      prev = (v - prev) * k + prev;
      out.push(prev);
    }
  }
  return out;
}
function stddev(values, period) {
  const out = [];
  for (let i = 0; i < values.length; i++) {
    if (i + 1 < period) { out.push(null); continue; }
    let sum = 0;
    let sum2 = 0;
    for (let j = i - period + 1; j <= i; j++) {
      const x = values[j];
      sum += x;
      sum2 += x * x;
    }
    const mean = sum / period;
    const variance = (sum2 / period) - mean * mean;
    out.push(Math.sqrt(Math.max(0, variance)));
  }
  return out;
}
function rsiArray(values, period = 14) {
  const out = [];
  let gains = 0, losses = 0;
  for (let i = 0; i < values.length; i++) {
    if (i === 0) { out.push(null); continue; }
    const change = values[i] - values[i - 1];
    const gain = Math.max(0, change);
    const loss = Math.max(0, -change);
    if (i <= period) {
      gains += gain;
      losses += loss;
      out.push(null);
      if (i === period) {
        const avgGain = gains / period;
        const avgLoss = losses / period;
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        out[i] = 100 - (100 / (1 + rs));
      }
      continue;
    }
    gains = (gains * (period - 1) + gain) / period;
    losses = (losses * (period - 1) + loss) / period;
    const rs = losses === 0 ? 100 : gains / losses;
    out.push(100 - (100 / (1 + rs)));
  }
  return out;
}

function computeIndicatorsFromBuffer(buf) {
  const closes = (Array.isArray(buf) ? buf.map(p => Number(p.v || p)) : []).filter(v => !Number.isNaN(v));
  const N = closes.length;
  if (N === 0) {
    return { close: [], macdHist: [], atrApprox: [], lastIndex: -1, ema9: [], ema50: [], rsi14: [], bb: { upper: [], lower: [] }, volume: [] };
  }

  const ema12 = emaArray(closes, 12);
  const ema26 = emaArray(closes, 26);
  const macdLine = closes.map((_, i) => (ema12[i] !== null && ema26[i] !== null) ? (ema12[i] - ema26[i]) : null);
  const macdSignal = emaArray(macdLine.map(x => x === null ? 0 : x), 9);
  const macdHist = macdLine.map((m, i) => (m === null || macdSignal[i] === null) ? 0 : (m - macdSignal[i]));

  const ema9 = emaArray(closes, 9);
  const ema50 = emaArray(closes, 50);

  const atrWindow = 14;
  const atrApprox = [];
  for (let i = 0; i < N; i++) {
    if (i === 0) { atrApprox.push(0); continue; }
    const diffs = [];
    for (let j = Math.max(1, i - atrWindow + 1); j <= i; j++) {
      diffs.push(Math.abs(closes[j] - closes[j - 1]));
    }
    const sum = diffs.reduce((a, b) => a + b, 0);
    atrApprox.push(sum / (diffs.length || 1));
  }

  const rsi14 = rsiArray(closes, 14);

  const bbPeriod = 20;
  const sd = stddev(closes, bbPeriod);
  const sma20 = sma(closes, bbPeriod);
  const bbUpper = [], bbLower = [];
  for (let i = 0; i < N; i++) {
    if (sma20[i] === null || sd[i] === null) { bbUpper.push(null); bbLower.push(null); }
    else {
      bbUpper.push(sma20[i] + 2 * sd[i]);
      bbLower.push(sma20[i] - 2 * sd[i]);
    }
  }

  return {
    close: closes,
    macdHist: macdHist,
    atrApprox: atrApprox,
    lastIndex: Math.max(0, closes.length - 1),
    ema9: ema9,
    ema50: ema50,
    rsi14: rsi14,
    bb: { upper: bbUpper, lower: bbLower },
    volume: []
  };
}

// build a compact indicator snapshot for logging/reasons
window.buildIndicatorReasonFromInd = function(ind, idx){
  try {
    if(!ind || idx === undefined || idx < 0) return null;
    const pick = (arr) => (arr && arr[idx] !== undefined) ? arr[idx] : null;
    const bbUpper = (ind.bb && ind.bb.upper) ? ind.bb.upper[idx] : null;
    const bbLower = (ind.bb && ind.bb.lower) ? ind.bb.lower[idx] : null;
    return {
      idx: idx,
      price: pick(ind.close),
      ema9: pick(ind.ema9),
      ema50: pick(ind.ema50),
      macdHist: pick(ind.macdHist),
      rsi14: pick(ind.rsi14),
      atrApprox: pick(ind.atrApprox),
      bbUpper: bbUpper,
      bbLower: bbLower
    };
  } catch(e){ return null; }
};

// expose a helper for other scripts to fetch the latest indicator snapshot
window.getIndicatorReason = function(){
  try {
    const ind = computeIndicatorsFromBuffer(window.buffer || []);
    const idx = ind.lastIndex;
    if(idx === undefined || idx < 0) return null;
    return window.buildIndicatorReasonFromInd ? window.buildIndicatorReasonFromInd(ind, idx) : null;
  } catch(e){ return null; }
};

function voteSignal(ind, idx) {
  try {
    if (!ind || idx === undefined || idx < 0) return { signal: 'neutral', score: { long: 0, short: 0 } };

    const close = (ind.close && ind.close[idx]) || 0;
    const ema9Val = (ind.ema9 && ind.ema9[idx]) || 0;
    const ema50Val = (ind.ema50 && ind.ema50[idx]) || 0;
    const macd = (ind.macdHist && ind.macdHist[idx]) || 0;
    const atr = (ind.atrApprox && ind.atrApprox[idx]) || 0;
    const rsi = (ind.rsi14 && ind.rsi14[idx]) || 50;
    const eps = 1e-9;

    let emaDiffPct = 0;
    if (Math.abs(ema50Val) > eps) emaDiffPct = (ema9Val - ema50Val) / Math.abs(ema50Val);
    const trendScore = Math.tanh(emaDiffPct * 10) * 0.5 + 0.5;
    const macdScore = (Math.tanh(macd * 5) * 0.5 + 0.5);
    const rsiScore = Math.max(0, Math.min(1, (rsi - 30) / 40));

    let longScore = (0.5 * trendScore + 0.3 * macdScore + 0.2 * rsiScore);
    let shortScore = (0.5 * (1 - trendScore) + 0.3 * (1 - macdScore) + 0.2 * (1 - rsiScore));

    const volFactor = Math.tanh((atr || 0) * 5) * 0.5 + 0.5;
    longScore *= (0.4 + 0.6 * volFactor);
    shortScore *= (0.4 + 0.6 * volFactor);

    longScore = Math.max(0, Math.min(100, longScore * 100));
    shortScore = Math.max(0, Math.min(100, shortScore * 100));

    let signal = 'neutral';
    if (longScore > shortScore && longScore > 55) signal = 'long';
    else if (shortScore > longScore && shortScore > 55) signal = 'short';
    else signal = 'neutral';

    return { signal, score: { long: longScore, short: shortScore } };
  } catch (e) {
    return { signal: 'neutral', score: { long: 0, short: 0 } };
  }
}
/* ---------- end indicator engine ---------- */
</script>

<!-- Your existing indicator script (updated to use the engine above and the new prepare->take logic with logs) -->
<script>
(function(){
  // replaced whenReady with an always-waiting version (no hard timeout)
  function whenReady(fn) {
    (function check(){
      // Wait for buffer array to be available and either a heroChart or at least one buffer point
      if (Array.isArray(window.buffer) && (window.heroChart || window.buffer.length >= 1)) {
        try { fn(); } catch(e){ console.error('indicator init failed', e); }
        return;
      }
      // keep retrying until ready
      setTimeout(check, 150);
    })();
  }

  // stake helpers (save/load UI)
  (function(){
    const STAKE_STORAGE = 'hero_selected_stake';
    const stakeInput = document.getElementById('stakeInput');
    const stakeSaveBtn = document.getElementById('stakeSaveBtn');

    function parseStake(v){
      try {
        let n = Number(v);
        if(Number.isNaN(n)) return null;
        n = Math.round(n * 100) / 100;
        if(n < 0.01) return null;
        return n;
      } catch(e){ return null; }
    }

    window.getStake = function(){
      try {
        if(stakeInput){
          const s = parseStake(stakeInput.value);
          if(s !== null) return s;
        }
        const saved = localStorage.getItem(STAKE_STORAGE);
        if(saved) {
          const s2 = parseStake(saved);
          if(s2 !== null) return s2;
        }
      } catch(e){}
      return 1.0;
    };

    try {
      if(stakeSaveBtn){
        stakeSaveBtn.addEventListener('click', function(){
          try {
            const s = parseStake(stakeInput.value);
            if(s === null){ alert('Invalid stake'); return; }
            localStorage.setItem(STAKE_STORAGE, String(s));
            stakeSaveBtn.textContent = 'Saved';
            setTimeout(()=>{ stakeSaveBtn.textContent = 'Save'; }, 900);
          } catch(e){ console.warn("stake save failed", e); }
        });
      }
    } catch(e){}

    try {
      const saved = localStorage.getItem('hero_selected_stake');
      if(saved && stakeInput) stakeInput.value = String(parseFloat(saved).toFixed(2));
    } catch(e){}
  })();

  whenReady(function() {
    const COMPUTE_INTERVAL_MS = 1000;

    // Tunables (changed to favor faster TAKEs while keeping confirmation)
    const PREPARE_PERC = 0.45;         // show PREPARE earlier
    const PREPARE_THRESHOLD = 0.55;   // require ~55% prepare to be eligible for TAKE
    const MIN_ADVANTAGE = 0.03;       // require small advantage over opposite prepare
    const TAKE_PERC = 0.65;           // TAKE threshold (65% per your request)
    const REALLY_GOOD_PERC = 0.82;
    const MIN_CONFIDENCE = 0.28;      // slightly lowered confidence requirement
    const PERSIST_TAKE_SECS = 0.5;    // require short persistence
    const PERSIST_TAKE_COUNT = Math.max(1, Math.round(PERSIST_TAKE_SECS / (COMPUTE_INTERVAL_MS/1000)));
    const TAKE_COOLDOWN_MS = 3000;    // shorter cooldown (3s) for testing
    const PREPARE_MIN_PERSIST_SEC = 0.5; // prepare must last at least this long before TAKE allowed
    const TEST_STAKE = 1.0;

    // UI elements
    const upBox = document.getElementById('ind-box-up');
    const downBox = document.getElementById('ind-box-down');
    const upPercentEl = document.getElementById('ind-up-percent');
    const downPercentEl = document.getElementById('ind-down-percent');
    const upStatusEl = document.getElementById('ind-up-status');
    const downStatusEl = document.getElementById('ind-down-status');
    const upStrengthEl = document.getElementById('ind-up-strength');
    const downStrengthEl = document.getElementById('ind-down-strength');
    const upTimerEl = document.getElementById('ind-up-timer');
    const downTimerEl = document.getElementById('ind-down-timer');
    const upNoteEl = document.getElementById('ind-up-note');
    const downNoteEl = document.getElementById('ind-down-note');

    // state (added prepare* fields)
    let upState = { state: 'HOLD', since: 0, consecutiveTake: 0, prepareSince: 0, preparePerc: 0 };
    let downState = { state: 'HOLD', since: 0, consecutiveTake: 0, prepareSince: 0, preparePerc: 0 };
    let lastTakeTs = 0;

    function signalLogAppend(txt) {
      try {
        const b = document.getElementById('herox-signal-log-body');
        if(!b) return;
        const el = document.createElement('div');
        el.style.fontSize='12px';
        el.style.padding='6px 4px';
        el.style.borderBottom='1px solid rgba(0,0,0,0.04)';
        el.textContent = `[${(new Date()).toLocaleTimeString()}] ${txt}`;
        b.insertBefore(el, b.firstChild);
        while(b.children.length>20) b.removeChild(b.lastChild);
      } catch(e){}
    }
    window.signalLogAppend = signalLogAppend;
    try {
      document.getElementById('herox-clear-log').addEventListener('click', function(){ try { document.getElementById('herox-signal-log-body').innerHTML = ''; } catch(e) {} });
    } catch(e){}

    function setBoxVisual(boxEl, statusEl, percentEl, strengthEl, timerEl, noteEl, stateObj, sideStyles) {
      try {
        const now = Date.now();
        const elapsed = stateObj.since ? Math.round((now - stateObj.since)/1000) : 0;
        timerEl.textContent = elapsed + 's';
        const st = stateObj.state;
        if(st === 'TAKE') {
          boxEl.style.background = sideStyles.takeBg;
          statusEl.style.color = sideStyles.takeColor;
          statusEl.textContent = 'TAKE';
          noteEl.style.display = '';
          noteEl.textContent = `TAKE | ${new Date().toLocaleTimeString()}`;
        } else if (st === 'PREPARE') {
          boxEl.style.background = sideStyles.prepareBg;
          statusEl.style.color = sideStyles.prepareColor;
          statusEl.textContent = 'PREPARE';
          noteEl.style.display = 'none';
        } else {
          boxEl.style.background = sideStyles.neutralBg;
          statusEl.style.color = 'rgba(0,0,0,0.6)';
          statusEl.textContent = 'HOLD';
          noteEl.style.display = 'none';
        }
      } catch(e){}
    }

    function safeComputeIndicators() {
      try { return computeIndicatorsFromBuffer(window.buffer); } catch(e) {
        return { close: window.buffer.map(p=>p.v||0), macdHist: [], atrApprox: [], lastIndex: Math.max(0, window.buffer.length-1), ema9: [], ema50: [], rsi14: [], bb: { upper: [], lower: [] }, volume: [] };
      }
    }
    function safeVote(ind, idx) {
      try { return voteSignal(ind, idx); } catch(e) {
        return { signal: 'neutral', score: { long: 0, short: 0 } };
      }
    }

    // For testing allow smaller gate (original used 12)
    const MIN_POINTS_GATE = 6;

    setInterval(function(){
      try {
        if (!window.__hlAnalysisRunning) {
          return;
        }
        // gate
        if (!Array.isArray(window.buffer) || window.buffer.length < MIN_POINTS_GATE) {
          // helpful debug: show buffer size
          if(window.buffer && window.buffer.length > 0 && window.buffer.length < MIN_POINTS_GATE){
            console.debug("[HEROX] waiting for gate, current buffer length:", window.buffer.length, "need:", MIN_POINTS_GATE);
          }
          return;
        }
        const ind = safeComputeIndicators();
        const idx = ind.lastIndex;
        const price = ind.close[idx];

        const vs = safeVote(ind, idx);
        const sl = (vs.score && vs.score.long) ? vs.score.long : 0;
        const ss = (vs.score && vs.score.short) ? vs.score.short : 0;
        const totalVotes = Math.max(1, sl + ss);
        const percLong = sl / totalVotes;
        const percShort = ss / totalVotes;
        const macdHist = (ind.macdHist && ind.macdHist[idx]) || 0;
        const atr = (ind.atrApprox && ind.atrApprox[idx]) || 0;
        const conf = (function(v){ const diff = Math.abs((v.score.long||0)-(v.score.short||0)); const sum = (v.score.long||0)+(v.score.short||0)+1e-9; return diff/sum; })(vs);

        // strength label
        const winPerc = Math.max(percLong, percShort);
        let strengthLabel = 'Weak';
        if (winPerc >= REALLY_GOOD_PERC) strengthLabel = 'Very good';
        else if (winPerc >= TAKE_PERC) strengthLabel = 'Good';
        else if (winPerc >= PREPARE_PERC) strengthLabel = 'Fair';

        // Update perc displays (rounded)
        upPercentEl.textContent = `${Math.round(percLong*100)}%`;
        downPercentEl.textContent = `${Math.round(percShort*100)}%`;
        upStrengthEl.textContent = `Strength: ${strengthLabel}`;
        downStrengthEl.textContent = `Strength: ${strengthLabel}`;

        // Decide raw candidates (we now prefer immediate TAKE if >= TAKE_PERC)
        const now = Date.now();
        let upCandidate = 'HOLD';
        if (percLong >= TAKE_PERC) upCandidate = 'TAKE';
        else if (percLong >= PREPARE_PERC) upCandidate = 'PREPARE';
        else upCandidate = 'HOLD';

        let downCandidate = 'HOLD';
        if (percShort >= TAKE_PERC) downCandidate = 'TAKE';
        else if (percShort >= PREPARE_PERC) downCandidate = 'PREPARE';
        else downCandidate = 'HOLD';

        // mutual exclusion guard
        if (upCandidate === 'TAKE' && downCandidate === 'TAKE') {
          if (Math.abs(percLong - percShort) < 0.06) { upCandidate = 'HOLD'; downCandidate = 'HOLD'; }
          else if (percLong > percShort) downCandidate = 'HOLD';
          else upCandidate = 'HOLD';
        }

        // Logging the voting and candidates for debugging
        console.debug("[HEROX INDICATOR] idx", idx, "price", price, "sl", sl, "ss", ss, "percLong", percLong, "percShort", percShort, "macdHist", macdHist, "atr", atr, "conf", conf, "upCand", upCandidate, "downCand", downCandidate);

        // HANDLE PREPARE states (no logging for PREPARE per your request)
        // UP prepare
        if (upCandidate === 'PREPARE') {
          if (upState.state !== 'PREPARE') {
            upState.state = 'PREPARE';
            upState.prepareSince = now;
            upState.preparePerc = percLong;
            upState.since = now;
          } else {
            if (percLong > upState.preparePerc) upState.preparePerc = percLong;
          }
        } else if (upCandidate === 'HOLD') {
          if (upState.state === 'PREPARE') { upState.state = 'HOLD'; upState.prepareSince = 0; upState.preparePerc = 0; upState.since = 0; }
        }

        // DOWN prepare
        if (downCandidate === 'PREPARE') {
          if (downState.state !== 'PREPARE') {
            downState.state = 'PREPARE';
            downState.prepareSince = now;
            downState.preparePerc = percShort;
            downState.since = now;
          } else {
            if (percShort > downState.preparePerc) downState.preparePerc = percShort;
          }
        } else if (downCandidate === 'HOLD') {
          if (downState.state === 'PREPARE') { downState.state = 'HOLD'; downState.prepareSince = 0; downState.preparePerc = 0; downState.since = 0; }
        }

        // CONFIRMATION: MACD zero-cross or EMA9/EMA50 cross (we keep it optional)
        const prevIdx = Math.max(0, idx - 1);
        const prevMacd = (ind.macdHist && ind.macdHist[prevIdx]) || 0;
        const prevEma9 = (ind.ema9 && ind.ema9[prevIdx]) || 0;
        const prevEma50 = (ind.ema50 && ind.ema50[prevIdx]) || 0;
        const prevEmaDiff = prevEma9 - prevEma50;
        const currEma9 = (ind.ema9 && ind.ema9[idx]) || 0;
        const currEma50 = (ind.ema50 && ind.ema50[idx]) || 0;
        const currEmaDiff = currEma9 - currEma50;

        const macdCrossUp = (prevMacd <= 0 && (ind.macdHist && ind.macdHist[idx]) > 0);
        const macdCrossDown = (prevMacd >= 0 && (ind.macdHist && ind.macdHist[idx]) < 0);
        const emaCrossUp = (prevEmaDiff <= 0 && currEmaDiff > 0);
        const emaCrossDown = (prevEmaDiff >= 0 && currEmaDiff < 0);

        // TAKE persistence handling
        // UP TAKE request
        if (upCandidate === 'TAKE') {
          // If it's >= TAKE_PERC we skip prepare gating to be faster for testing
          let prepareOk = true;
          if (!(upState.state === 'PREPARE' && upState.preparePerc >= PREPARE_THRESHOLD && upState.preparePerc >= (downState.preparePerc + MIN_ADVANTAGE) && ((now - (upState.prepareSince || 0)) >= (PREPARE_MIN_PERSIST_SEC * 1000)))) {
            // only allow skipping prepare if value is actually >= TAKE_PERC (we're already here)
            if (upState.state !== 'PREPARE' && upState.preparePerc < PREPARE_THRESHOLD) {
              // allow immediate TAKE because we use the 65% fast rule
              prepareOk = true;
            }
          }
          const confirmed = prepareOk && (macdCrossUp || emaCrossUp || conf >= 0.45);
          // allow confirmed OR force by threshold
          if (prepareOk || conf >= 0.12) {
            upState.consecutiveTake++;
            if (!upState.since) upState.since = now;
          } else {
            upState.consecutiveTake = 0;
          }
        } else {
          upState.consecutiveTake = 0;
        }

        // DOWN TAKE request
        if (downCandidate === 'TAKE') {
          let prepareOk = true;
          if (!(downState.state === 'PREPARE' && downState.preparePerc >= PREPARE_THRESHOLD && downState.preparePerc >= (upState.preparePerc + MIN_ADVANTAGE) && ((now - (downState.prepareSince || 0)) >= (PREPARE_MIN_PERSIST_SEC * 1000)))) {
            if (downState.state !== 'PREPARE' && downState.preparePerc < PREPARE_THRESHOLD) {
              prepareOk = true;
            }
          }
          const confirmed = prepareOk && (macdCrossDown || emaCrossDown || conf >= 0.45);
          if (prepareOk || conf >= 0.12) {
            downState.consecutiveTake++;
            if (!downState.since) downState.since = now;
          } else {
            downState.consecutiveTake = 0;
          }
        } else {
          downState.consecutiveTake = 0;
        }

        // Emit TAKE for UP if persist count satisfied and tick-based cooldown passed
        if (upState.consecutiveTake >= PERSIST_TAKE_COUNT && !(window.isTradePending && window.isTradePending())) {
          // tick-based separation: require N ticks since last TAKE
          const TICKS_BETWEEN_TAKES = 8;
          const ticksSinceLast = (window.__herox_tick_counter || 0) - (window.__herox_last_take_tick || 0);
          if (ticksSinceLast >= TICKS_BETWEEN_TAKES) {
            // register this TAKE by recording the tick index and timestamp
            window.__herox_last_take_tick = (window.__herox_tick_counter || 0);
            upState.state = 'TAKE';
            upState.since = now;
            lastTakeTs = now;
            signalLogAppend && signalLogAppend(`TAKE HIGHER ${Math.round(percLong*100)}% | conf ${Math.round(conf*100)}%`);
            console.info("[HEROX] TAKE HIGHER", {percLong, conf, macdHist, atr, macdCrossUp, emaCrossUp});

            // send forced trade (force true) regardless of autotrade toggle (as requested)
            (async function(){
              try {
                const payload = {
                  signal: 'higher',
                  symbol: (window.SYMBOL||'RDBEAR'),
                  direction: 'higher',
                  contract_type: 'CALL',
                  barrier: "-1",
                  mode: getSelectedMode() || 'demo',
                  stake: (window.getStake ? window.getStake() : TEST_STAKE),
                  duration: 5,
                  duration_unit: 't',
                  confidence: conf,
                  percent: percLong,
                  force: true,
                  reason: { indicators: (window.buildIndicatorReasonFromInd ? window.buildIndicatorReasonFromInd(ind, idx) : null), vote: vs, percLong, percShort, conf, macdHist: macdHist, atr: atr, macdCrossUp, emaCrossUp },
                  ts: Date.now()
                };
                const r = await (window.sendTradePayload ? window.sendTradePayload(payload) : null);
                console.debug("Autotrade/HIGHER send result", r);
                if (signalLogAppend) {
                  if (r && r.blocked) {
                    signalLogAppend(`Autotrade HIGHER skipped: pending trade (${r.blocked_by || 'unknown'})`);
                  } else {
                    const accepted = !!(r && r.ok && r.json && r.json.ok);
                    const outcome = (r && r.json && (r.json.result || r.json.outcome || r.json.status)) ? String(r.json.result || r.json.outcome || r.json.status).toUpperCase() : 'PENDING';
                    signalLogAppend(`Autotrade HIGHER ${accepted ? 'accepted' : 'failed'} (HTTP ${r ? r.status : 'no-caller'}) | outcome ${outcome}`);
                  }
                }
              } catch (e) {
                console.error("Autotrade HIGHER failed", e);
                signalLogAppend && signalLogAppend(`Autotrade failed: ${String(e)}`);
              }
            })();

            // reset prepares and counters after TAKE
            upState.consecutiveTake = 0;
            downState.consecutiveTake = 0;
            upState.prepareSince = 0; upState.preparePerc = 0; upState.state = 'TAKE';
            downState.prepareSince = 0; downState.preparePerc = 0; downState.state = 'HOLD'; downState.since = 0;
          }
        }
        else if (upState.consecutiveTake >= PERSIST_TAKE_COUNT && (window.isTradePending && window.isTradePending())) {
          upState.consecutiveTake = 0;
        }

        // Emit TAKE for DOWN if persist count satisfied and tick-based cooldown passed
        if (downState.consecutiveTake >= PERSIST_TAKE_COUNT && !(window.isTradePending && window.isTradePending())) {
          // tick-based separation: require N ticks since last TAKE
          const TICKS_BETWEEN_TAKES = 8;
          const ticksSinceLast = (window.__herox_tick_counter || 0) - (window.__herox_last_take_tick || 0);
          if (ticksSinceLast >= TICKS_BETWEEN_TAKES) {
            // register this TAKE by recording the tick index and timestamp
            window.__herox_last_take_tick = (window.__herox_tick_counter || 0);
            downState.state = 'TAKE';
            downState.since = now;
            lastTakeTs = now;
            signalLogAppend && signalLogAppend(`TAKE LOWER ${Math.round(percShort*100)}% | conf ${Math.round(conf*100)}%`);
            console.info("[HEROX] TAKE LOWER", {percShort, conf, macdHist, atr, macdCrossDown, emaCrossDown});

            (async function(){
              try {
                const payload = {
                  signal: 'lower',
                  symbol: (window.SYMBOL||'RDBEAR'),
                  direction: 'lower',
                  contract_type: 'PUT',
                  barrier: "+1",
                  mode: getSelectedMode() || 'demo',
                  stake: (window.getStake ? window.getStake() : TEST_STAKE),
                  duration: 5,
                  duration_unit: 't',
                  confidence: conf,
                  percent: percShort,
                  force: true,
                  reason: { indicators: (window.buildIndicatorReasonFromInd ? window.buildIndicatorReasonFromInd(ind, idx) : null), vote: vs, percLong, percShort, conf, macdHist: macdHist, atr: atr, macdCrossDown, emaCrossDown },
                  ts: Date.now()
                };
                const r = await (window.sendTradePayload ? window.sendTradePayload(payload) : null);
                console.debug("Autotrade/LOWER send result", r);
                if (signalLogAppend) {
                  if (r && r.blocked) {
                    signalLogAppend(`Autotrade LOWER skipped: pending trade (${r.blocked_by || 'unknown'})`);
                  } else {
                    const accepted = !!(r && r.ok && r.json && r.json.ok);
                    const outcome = (r && r.json && (r.json.result || r.json.outcome || r.json.status)) ? String(r.json.result || r.json.outcome || r.json.status).toUpperCase() : 'PENDING';
                    signalLogAppend(`Autotrade LOWER ${accepted ? 'accepted' : 'failed'} (HTTP ${r ? r.status : 'no-caller'}) | outcome ${outcome}`);
                  }
                }
              } catch (e) {
                console.error("Autotrade LOWER failed", e);
                signalLogAppend && signalLogAppend(`Autotrade failed: ${String(e)}`);
              }
            })();

            downState.consecutiveTake = 0;
            upState.consecutiveTake = 0;
            downState.prepareSince = 0; downState.preparePerc = 0; downState.state = 'TAKE';
            upState.prepareSince = 0; upState.preparePerc = 0; upState.state = 'HOLD'; upState.since = 0;
          }
        }
        else if (downState.consecutiveTake >= PERSIST_TAKE_COUNT && (window.isTradePending && window.isTradePending())) {
          downState.consecutiveTake = 0;
        }

        // Update UI visuals (PREPARE still shows visually; but only TAKE logs)
        const upStyles = { prepareBg: '#f0fdf4', takeBg: '#ecfdf5', neutralBg: '#f8fff9', prepareColor: '#065f46', takeColor: '#065f46' };
        setBoxVisual(upBox, upStatusEl, upPercentEl, upStrengthEl, upTimerEl, upNoteEl, upState, upStyles);
        const downStyles = { prepareBg: '#fff1f2', takeBg: '#fee2e2', neutralBg: '#fff7f8', prepareColor: '#7f1d1d', takeColor: '#7f1d1d' };
        setBoxVisual(downBox, downStatusEl, downPercentEl, downStrengthEl, downTimerEl, downNoteEl, downState, downStyles);

      } catch(e){
        console.error("[HEROX] indicator loop error", e);
        // safe ignore
      }
    }, COMPUTE_INTERVAL_MS);

  });
})();
</script>

<!-- Balance DOM helpers (applyToDOM + polling) -->
<script>
(function(){
  const balancesWrap = document.getElementById('balancesWrap');
  const btnToggleBalances = document.getElementById('btnToggleBalances');
  let _balancePollId = null;
  let _balancesVisible = localStorage.getItem('hero_balances_visible') !== '0';

  function extractBalanceValue(obj){
    if(obj === null || obj === undefined) return null;
    if(typeof obj === 'number' || typeof obj === 'string') return Number(obj);
    if(obj.balance !== undefined) return Number(obj.balance);
    if(obj.available_balance !== undefined) return Number(obj.available_balance);
    for(const k of Object.keys(obj || {})){
      const n = Number(obj[k]);
      if(!Number.isNaN(n)) return n;
    }
    return null;
  }

  function formatBalance(v){
    if(v === null || v === undefined || Number.isNaN(Number(v))) return 'N/A';
    return Number(v).toFixed(2);
  }

  function renderBalanceCard(label, value, modeClass){
    return `<div class="balance-card ${modeClass}"><span class="balance-label">${label}</span><span class="balance-value">${formatBalance(value)}</span></div>`;
  }

  function setBalancesVisible(nextVisible){
    try {
      _balancesVisible = !!nextVisible;
      localStorage.setItem('hero_balances_visible', _balancesVisible ? '1' : '0');
      if(balancesWrap) balancesWrap.style.display = _balancesVisible ? 'flex' : 'none';
      if(btnToggleBalances) btnToggleBalances.textContent = _balancesVisible ? 'Hide Balances' : 'Show Balances';
    } catch(e){}
  }

  try {
    if(btnToggleBalances){
      btnToggleBalances.addEventListener('click', function(){
        setBalancesVisible(!_balancesVisible);
      });
    }
  } catch(e){}

  window.applyToDOM = function(mode, obj){
    try {
      if(!balancesWrap) return;
      let content = '';
      try {
        const demoSavedRaw = localStorage.getItem('hero_balance_demo');
        const realSavedRaw = localStorage.getItem('hero_balance_real');
        const demoSaved = demoSavedRaw ? JSON.parse(demoSavedRaw) : null;
        const realSaved = realSavedRaw ? JSON.parse(realSavedRaw) : null;

        if(mode && obj){
          const modeClass = mode === 'real' ? 'real' : 'demo';
          const modeLabel = modeClass === 'real' ? 'REAL' : 'DEMO';
          content = renderBalanceCard(modeLabel, extractBalanceValue(obj), modeClass);
        } else if(demoSaved || realSaved){
          if(demoSaved) content += renderBalanceCard('DEMO', extractBalanceValue(demoSaved), 'demo');
          if(realSaved) content += renderBalanceCard('REAL', extractBalanceValue(realSaved), 'real');
        } else {
          content = `<div class="balance-muted">Balance unavailable</div>`;
        }
      } catch(e){
        content = `<div class="balance-muted">Balance unavailable</div>`;
      }
      balancesWrap.innerHTML = content;
    } catch(e){ console.warn('applyToDOM failed', e); }
  };

  window.startHeaderBalancePolling = function(){
    try {
      if(_balancePollId) return;
      (async ()=>{ await fetchBalancesForMode(getSelectedMode()); })();
      _balancePollId = setInterval(()=>{ fetchBalancesForMode(getSelectedMode()); }, 4000);
    } catch(e){ console.warn('startHeaderBalancePolling failed', e); }
  };

  window.stopHeaderBalancePolling = function(){
    try { if(_balancePollId){ clearInterval(_balancePollId); _balancePollId = null; } } catch(e){}
  };

  window.loadSavedBalances = function(){
    try {
      const md = getSelectedMode();
      const raw = localStorage.getItem('hero_balance_' + md);
      if(!raw) return;
      const j = JSON.parse(raw);
      if(j) window.applyToDOM(md, j);
    } catch(e){ console.warn('loadSavedBalances failed', e); }
  };

  try {
    setBalancesVisible(_balancesVisible);
    loadSavedBalances();
  } catch(e){}
})();
</script>

<script src="/static/hero_assistant_panel.js"></script>

</body>
</html>



